<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="后端," />





  <link rel="alternate" href="/atom.xml" title="老战博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="后端知识点总结JavaJAVA内存堆栈 栈主要储存简单的变量，如int， string等基本类型，而函数和对象和数组存在堆中，使用引用赋值。 使用new的对象直接保存在堆中 栈由系统分配，程序员分配堆，JVM垃圾回收机制回收堆内存，栈使用完成立即释放。 引用传递function(ref int a)直接传递内存地址，局部变量a的操作会改变内存，数组char[n]传递为引用传递 int a = 1;">
<meta name="keywords" content="后端">
<meta property="og:type" content="article">
<meta property="og:title" content="后端知识点总结">
<meta property="og:url" content="https://zx19951110.github.io/ZX.github.io/2018/10/24/后端知识点总结/index.html">
<meta property="og:site_name" content="老战博客">
<meta property="og:description" content="后端知识点总结JavaJAVA内存堆栈 栈主要储存简单的变量，如int， string等基本类型，而函数和对象和数组存在堆中，使用引用赋值。 使用new的对象直接保存在堆中 栈由系统分配，程序员分配堆，JVM垃圾回收机制回收堆内存，栈使用完成立即释放。 引用传递function(ref int a)直接传递内存地址，局部变量a的操作会改变内存，数组char[n]传递为引用传递 int a = 1;">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://uploadfiles.nowcoder.net/images/20170623/2527957_1498180954324_D83CBF646B3F43FE947460F6D7231780">
<meta property="og:updated_time" content="2018-10-24T10:55:09.501Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="后端知识点总结">
<meta name="twitter:description" content="后端知识点总结JavaJAVA内存堆栈 栈主要储存简单的变量，如int， string等基本类型，而函数和对象和数组存在堆中，使用引用赋值。 使用new的对象直接保存在堆中 栈由系统分配，程序员分配堆，JVM垃圾回收机制回收堆内存，栈使用完成立即释放。 引用传递function(ref int a)直接传递内存地址，局部变量a的操作会改变内存，数组char[n]传递为引用传递 int a = 1;">
<meta name="twitter:image" content="https://uploadfiles.nowcoder.net/images/20170623/2527957_1498180954324_D83CBF646B3F43FE947460F6D7231780">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zx19951110.github.io/ZX.github.io/2018/10/24/后端知识点总结/"/>





  <title>后端知识点总结 | 老战博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">老战博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://zx19951110.github.io/ZX.github.io/2018/10/24/后端知识点总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhanxu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老战博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">后端知识点总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-24T11:49:52+02:00">
                2018-10-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="后端知识点总结"><a href="#后端知识点总结" class="headerlink" title="后端知识点总结"></a>后端知识点总结</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="JAVA内存堆栈"><a href="#JAVA内存堆栈" class="headerlink" title="JAVA内存堆栈"></a>JAVA内存堆栈</h3><ul>
<li>栈主要储存简单的变量，如int， string等基本类型，而函数和对象和数组存在堆中，使用引用赋值。</li>
<li>使用new的对象直接保存在堆中</li>
<li>栈由系统分配，程序员分配堆，JVM垃圾回收机制回收堆内存，栈使用完成立即释放。</li>
<li>引用传递function(ref int a)直接传递内存地址，局部变量a的操作会改变内存，数组char[n]传递为引用传递</li>
<li>int a = 1; b = a； unset(a) b依然存在，因为先开辟了“1”的内存空间然后使a指向“1”的空间，然后使b指向“1”的内存空间，当unset(a)时，b仍然指向1。</li>
</ul>
<h3 id="Final关键字"><a href="#Final关键字" class="headerlink" title="Final关键字"></a>Final关键字</h3><p>final变量：</p>
<ul>
<li><p>final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。</p>
</li>
<li><p>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p>
</li>
</ul>
<p>final 方法：</p>
<ul>
<li><p>类中的 final 方法可以被子类继承，但是不能被子类修改。</p>
</li>
<li><p>声明 final 方法的主要目的是防止该方法的内容被修改。</p>
</li>
</ul>
<p>final 类：</p>
<ul>
<li>final 类不能被继承，没有类能够继承 final 类的任何特性。</li>
</ul>
<p>当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="==用法"></a>==用法</h3><p>==强调栈中的比较，可以理解为地址比较<br>，equals强调对象的内容比较</p>
<h3 id="类初始化顺序"><a href="#类初始化顺序" class="headerlink" title="类初始化顺序"></a>类初始化顺序</h3><p>无继承情况：</p>
<ol>
<li>静态变量</li>
<li>静态初始化块</li>
<li>变量</li>
<li>初始化块</li>
<li>构造器</li>
</ol>
<p>继承情况：</p>
<ol>
<li>父类–静态变量</li>
<li>父类–静态初始化块</li>
<li>子类–静态变量</li>
<li>子类–静态初始化块</li>
<li>父类–变量</li>
<li>父类–初始化块</li>
<li>父类–构造器</li>
<li>子类–变量</li>
<li>子类–初始化块</li>
<li>子类–构造器</li>
</ol>
<p>子类的构造方法总是先调用父类的构造方法，如果子类的构造方法没有明显地指明使用父类的哪个构造方法，子类就调用父类不带参数的构造方法。子类的构造方法的第一行隐式的默认调用父类的无参构造器即super()</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>线程状态</p>
<ul>
<li>新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();</li>
<li>就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，<strong>并不是说执行了t.start()此线程立即就会执行；</strong></li>
<li>运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</li>
<li><p>阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p>
<ul>
<li>等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</li>
<li>同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</li>
<li>其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
</ul>
</li>
<li><p>死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>
</li>
</ul>
<h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h3><ul>
<li>每个对象都有一个锁来控制同步访问，Synchronized关键字可以和对象的锁交互，来实现同步方法或同步块。执行sleep()方法后正在执行的线程主动让出CPU（然后CPU就可以去执行其他任务），在sleep指定时间后CPU再回到该线程继续往下执行(<strong>注意：sleep方法只让出了CPU，而并不会释放同步资源锁！！！</strong>)；wait()方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，<strong>只有调用了notify()方法，之前调用wait()的线程才会解除wait状态</strong>，可以去参与竞争同步资源锁，进而得到执行。（注意：notify的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说notify只是让之前调用wait的线程有权利重新参与线程的调度）；</li>
<li>sleep()方法可以在任何地方使用；wait()方法则只能在同步方法或同步块中使用；</li>
<li>sleep()是线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait()是Object的方法，调用会放弃对象锁，进入等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才会进入锁池，再次获得对象锁才会进入运行状态；</li>
</ul>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul>
<li>Vector  HashTable  StringBuffer  statck enumeration是线程安全的.</li>
<li>ArrayList、 LinkedList、HashMap、StringBuilder 是非线程安全的。</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p> 产生死锁的原因主要是：</p>
<ol>
<li><p>因为系统资源不足。</p>
</li>
<li><p>进程运行推进的顺序不合适。</p>
</li>
<li><p>资源分配不当等。    </p>
</li>
</ol>
<p>导致死锁的4个必要条件：</p>
<ol>
<li><p>互斥条件。一次只有一个进程可以使用一个资源。其他进程不能访问已分配给其他进程的资源。</p>
</li>
<li><p>请求保持条件。当一个进程等待其他进程时，继续占有已经分配的资源。</p>
</li>
<li><p>不可剥夺条件。不能强行抢占进程已占有的资源。</p>
</li>
<li><p>循环等待条件。存在一个封闭的进程链，使得每个进程至少占有此链中下一个进程所需要的一个资源。</p>
</li>
</ol>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。</p>
<ul>
<li><p>当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</p>
</li>
<li><p>然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。</p>
</li>
<li><p>尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。</p>
</li>
<li><p>当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。</p>
</li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Factor(负载因子)则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p>
<p>当key出现hash冲突的时候,链表中的第一个元素都是后面最新添加进来的那个,之前的则被next变量引用着。虽然这里是插入的动作,但是由于使用了链表,所以无需像数组的插入那样,进行数组拷贝。</p>
<h3 id="ArrayList-和-LinkList"><a href="#ArrayList-和-LinkList" class="headerlink" title="ArrayList 和 LinkList"></a>ArrayList 和 LinkList</h3><p>ArrayList与linkedList在性能上各有优缺点，都有各自的地方，</p>
<p>1.对ArrayList和LinkedList而言，在列表中末尾添加一个元素所花的开销是固定的</p>
<p>2.在ArrayList中间插入一个元素或删除一个元素意味着整个列表中剩余的元素都会移动，而LinkedList的中间插入或删除一个元素的开销是固定的</p>
<p>3.LinkedList不支持高效的随机访问</p>
<p> 可以这样说：当操作是在一列数据后面添加数据而不是在前面或中间，并且是随机访问其中元素时，使用arrayList会提供比较好的性能；当你操作是在一列数据的前面或中间添加或删除数据，并不是按照顺序访问其中的元素，就应该使用LinkedList了</p>
<h3 id="线程-join"><a href="#线程-join" class="headerlink" title="线程 join"></a>线程 join</h3><p>主线程(我在“一”里已经命名过了)等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。(Waits for this thread to die.)</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p> 总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p> 总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。</p>
<h3 id="Synchronized与ReentrantLock的区别"><a href="#Synchronized与ReentrantLock的区别" class="headerlink" title="Synchronized与ReentrantLock的区别"></a>Synchronized与ReentrantLock的区别</h3><p>对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成。</p>
<h3 id="美团Java2018面试模拟题经验"><a href="#美团Java2018面试模拟题经验" class="headerlink" title="美团Java2018面试模拟题经验"></a>美团Java2018面试模拟题经验</h3><ul>
<li><p>try{}语句块内不论有错误还是有return都会执行finally语句块，但下面的语句块不会再执行</p>
</li>
<li><p>RuntimeException 使用try{}，catc{}捕获不是必须的</p>
</li>
<li><p>sleep()方法并不会让出cpu</p>
</li>
<li><p>如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承</p>
</li>
<li>finally在异常处理时提供 finally 块来执行任何清除操作</li>
<li>Java使用 finalize() 方法在垃圾收集器象从内存中清除出去之前做必要的清理工作</li>
<li>static{}静态代码块首先执行，即，静态代码块-&gt;非静态代码块-&gt;构造器</li>
<li>Object类中没有copy方法</li>
<li>接口只能用public修饰，并且是抽象的；其中只能是抽象方法</li>
<li>子类不能继承父类构造方法，一个子类只能继承一个父类</li>
<li>构造方法是一种特殊的方法，它是一个与类同名且没有返回值类型的方法。</li>
<li>int 和Integer在进行比较的时候，Integer会进行拆箱，转为int值与int进行比较。整Integer字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象</li>
<li>Integer i01 = 59，java在编译的时候,被翻译成-&gt; Integer i01 = Integer.valueOf(59);</li>
<li>初始化时int类的变量初始为0.而Integer的变量则初始化为null.</li>
<li>自动装箱:Integer字面量的值在-128到127之间, Integer a = 127;相当于Integer a = new Integer(127)</li>
<li>方法中的<strong>局部变量</strong>，存放在栈区,类中的<strong>成员变量</strong>，存放在堆区</li>
<li>JAVA语言不允许程序员直接控制内存空间的使用。内存空间的分配和回收都是由JRE负责在后台自动进行的，尤其是无用内存空间的回收操作 (garbagecollection,也称垃圾回收)，只能由运行环境提供的一个超级线程进行监测和控制。</li>
</ul>
<h3 id="Byte范围"><a href="#Byte范围" class="headerlink" title="Byte范围"></a>Byte范围</h3><p>是-128~127 127+1=-128</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>没有返回类型，并不是void</p>
<h3 id="Java源程序"><a href="#Java源程序" class="headerlink" title="Java源程序"></a>Java源程序</h3><p>一个源程序只能有一个public类存在，且类名与文件名相同.</p>
<h3 id="抽象类："><a href="#抽象类：" class="headerlink" title="抽象类："></a>抽象类：</h3><ul>
<li>抽象类不能实例化，因为有抽象方法未实现</li>
<li>可以被继承。派生类可以实现抽象方法</li>
<li>子类可以是抽象的，也可以非抽象的</li>
<li>可以被抽象类继承，也可以被非抽象类继承</li>
</ul>
<h3 id="Java类成员的访问控制权限："><a href="#Java类成员的访问控制权限：" class="headerlink" title="Java类成员的访问控制权限："></a>Java类成员的访问控制权限：</h3><p><strong>public &gt; protected &gt; 同包（default） &gt; private</strong></p>
<p><img src="https://uploadfiles.nowcoder.net/images/20170623/2527957_1498180954324_D83CBF646B3F43FE947460F6D7231780" alt=""></p>
<h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><p>子类重写父类方法，调用时会调用子类重写之后的方法，包括父类构造器中调用父类的方法会变成重载后子类的方法，注意实例化顺序</p>
<h3 id="包导入"><a href="#包导入" class="headerlink" title="包导入"></a>包导入</h3><p>Java.awt.*只能导入awt这个包中的所有类，awt中的包中的类不会导入</p>
<h3 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h3><p>执行 Base b = new Sub();时由于多态 b编译时表现为Base类特性，运行时表现为Sub类特性，编译看左边，运行看右边。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类其实和类的属性没什么区别，只是在声明的时候必须是Outer.Inner a</p>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><h3 id="错误控制"><a href="#错误控制" class="headerlink" title="错误控制"></a>错误控制</h3><p>php 支持一个错误控制运算符：@。当将其放置在一个 php 表达式之前，该表达式可能产生的任何错误信息都被忽略掉</p>
<h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>php实例化类无参数可不带括号</p>
<h3 id="关联数组无key情况"><a href="#关联数组无key情况" class="headerlink" title="关联数组无key情况"></a>关联数组无key情况</h3><p>对关联数组新增不带键的元素，若前面的元素有数字（或数字字符）键，新增元素的键为前面最大的数字加1。若前面的元素无数字键，新增元素的键为0。</p>
<h3 id="empty函数"><a href="#empty函数" class="headerlink" title="empty函数"></a>empty函数</h3><p>bool  empty  (  mixed $var )<br>如果 var 是非空或非零的值，则  empty()  返回 FALSE。换句话说，””、0、”0”、NULL、FALSE、array()、var $var; 以及没有任何属性的对象都将被认为是空的，如果 var 为空，则返回 TRUE。</p>
<h3 id="unset函数"><a href="#unset函数" class="headerlink" title="unset函数"></a>unset函数</h3><p>unset($a)相当于对$a变量内存引用-1，如果引用为0才回收内存。</p>
<h3 id="PHP-final"><a href="#PHP-final" class="headerlink" title="PHP final"></a>PHP final</h3><p>php和Java不同，Java中类属性是可以用final修饰表示的是常量，PHP不能，因为PHP的常量只能用define定义。</p>
<ul>
<li>final—用于类、方法前。  </li>
<li>final类—不可被继承。  </li>
<li>final方法—不可被覆盖。</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/后端/" rel="tag"># 后端</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/12/Linux备注/" rel="next" title="Linux备注">
                <i class="fa fa-chevron-left"></i> Linux备注
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/24/数据库知识点总结/" rel="prev" title="数据库知识点总结">
                数据库知识点总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="zhanxu" />
          <p class="site-author-name" itemprop="name">zhanxu</p>
           
              <p class="site-description motion-element" itemprop="description">老战的程序猿成长踩坑路程</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ZX19951110" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/zhan-xu-41/activities" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://619186893.lofter.com/" target="_blank" title="Lofter">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Lofter
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#后端知识点总结"><span class="nav-number">1.</span> <span class="nav-text">后端知识点总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java"><span class="nav-number">1.1.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JAVA内存堆栈"><span class="nav-number">1.1.1.</span> <span class="nav-text">JAVA内存堆栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Final关键字"><span class="nav-number">1.1.2.</span> <span class="nav-text">Final关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用法"><span class="nav-number">1.1.3.</span> <span class="nav-text">==用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类初始化顺序"><span class="nav-number">1.1.4.</span> <span class="nav-text">类初始化顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程"><span class="nav-number">1.1.5.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep和wait的区别"><span class="nav-number">1.1.6.</span> <span class="nav-text">sleep和wait的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全"><span class="nav-number">1.1.7.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">1.1.8.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized"><span class="nav-number">1.1.9.</span> <span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap"><span class="nav-number">1.1.10.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-和-LinkList"><span class="nav-number">1.1.11.</span> <span class="nav-text">ArrayList 和 LinkList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程-join"><span class="nav-number">1.1.12.</span> <span class="nav-text">线程 join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#乐观锁"><span class="nav-number">1.1.13.</span> <span class="nav-text">乐观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#悲观锁"><span class="nav-number">1.1.14.</span> <span class="nav-text">悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronized与ReentrantLock的区别"><span class="nav-number">1.1.15.</span> <span class="nav-text">Synchronized与ReentrantLock的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#美团Java2018面试模拟题经验"><span class="nav-number">1.1.16.</span> <span class="nav-text">美团Java2018面试模拟题经验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Byte范围"><span class="nav-number">1.1.17.</span> <span class="nav-text">Byte范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造器"><span class="nav-number">1.1.18.</span> <span class="nav-text">构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java源程序"><span class="nav-number">1.1.19.</span> <span class="nav-text">Java源程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类："><span class="nav-number">1.1.20.</span> <span class="nav-text">抽象类：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java类成员的访问控制权限："><span class="nav-number">1.1.21.</span> <span class="nav-text">Java类成员的访问控制权限：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写与重载"><span class="nav-number">1.1.22.</span> <span class="nav-text">重写与重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包导入"><span class="nav-number">1.1.23.</span> <span class="nav-text">包导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译与运行"><span class="nav-number">1.1.24.</span> <span class="nav-text">编译与运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类"><span class="nav-number">1.1.25.</span> <span class="nav-text">内部类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP"><span class="nav-number">1.2.</span> <span class="nav-text">PHP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#错误控制"><span class="nav-number">1.2.1.</span> <span class="nav-text">错误控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例化"><span class="nav-number">1.2.2.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关联数组无key情况"><span class="nav-number">1.2.3.</span> <span class="nav-text">关联数组无key情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#empty函数"><span class="nav-number">1.2.4.</span> <span class="nav-text">empty函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unset函数"><span class="nav-number">1.2.5.</span> <span class="nav-text">unset函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PHP-final"><span class="nav-number">1.2.6.</span> <span class="nav-text">PHP final</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhanxu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
