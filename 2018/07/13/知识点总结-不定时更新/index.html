<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="老战博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="知识点总结(不定时更新)2018-07-12数据库事务四个特性ACID  原子性（Atomicity）： 操作要么全部完成，要么全部回滚。 一致性（Consistency）： 事务使数据库的一个一致性状态变为另一个一致性状态，事务执行不改变数据库一致性。 隔离性（Isolation）： 多用户事务并发访问事务之间隔离。 持久性（Durability）： 持久性是指一个事务一旦被提交了，那么对数据库">
<meta property="og:type" content="article">
<meta property="og:title" content="知识点总结(不定时更新)">
<meta property="og:url" content="https://zx19951110.github.io/ZX.github.io/2018/07/13/知识点总结-不定时更新/index.html">
<meta property="og:site_name" content="老战博客">
<meta property="og:description" content="知识点总结(不定时更新)2018-07-12数据库事务四个特性ACID  原子性（Atomicity）： 操作要么全部完成，要么全部回滚。 一致性（Consistency）： 事务使数据库的一个一致性状态变为另一个一致性状态，事务执行不改变数据库一致性。 隔离性（Isolation）： 多用户事务并发访问事务之间隔离。 持久性（Durability）： 持久性是指一个事务一旦被提交了，那么对数据库">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://images0.cnblogs.com/blog/138012/201409/241708372951952.png">
<meta property="og:image" content="https://images0.cnblogs.com/blog/138012/201409/251447377485132.png">
<meta property="og:image" content="https://images0.cnblogs.com/blog/138012/201409/251448515607115.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1074709/201712/1074709-20171229165319538-1026266241.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1074709/201712/1074709-20171229170434726-2010021622.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1074709/201712/1074709-20171229171503867-2027149651.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1074709/201712/1074709-20171229172802179-389908324.png">
<meta property="og:image" content="https://uploadfiles.nowcoder.net/images/20160731/213669_1469934373582_04341C4C965D57F74167CCE72D2EAF7B">
<meta property="og:image" content="https://uploadfiles.nowcoder.net/images/20160731/213669_1469934384802_F3CB514AAFC503A1BCD00D1B81F87ED1">
<meta property="og:image" content="https://uploadfiles.nowcoder.net/images/20170623/2527957_1498180954324_D83CBF646B3F43FE947460F6D7231780">
<meta property="og:image" content="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=ea3d88e2269759ee4a5067cd8ac0242b/94cad1c8a786c9179df9bed6c93d70cf3ac75763.jpg">
<meta property="og:updated_time" content="2018-08-18T10:41:40.003Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="知识点总结(不定时更新)">
<meta name="twitter:description" content="知识点总结(不定时更新)2018-07-12数据库事务四个特性ACID  原子性（Atomicity）： 操作要么全部完成，要么全部回滚。 一致性（Consistency）： 事务使数据库的一个一致性状态变为另一个一致性状态，事务执行不改变数据库一致性。 隔离性（Isolation）： 多用户事务并发访问事务之间隔离。 持久性（Durability）： 持久性是指一个事务一旦被提交了，那么对数据库">
<meta name="twitter:image" content="https://images0.cnblogs.com/blog/138012/201409/241708372951952.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zx19951110.github.io/ZX.github.io/2018/07/13/知识点总结-不定时更新/"/>





  <title>知识点总结(不定时更新) | 老战博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">老战博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://zx19951110.github.io/ZX.github.io/2018/07/13/知识点总结-不定时更新/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhanxu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老战博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">知识点总结(不定时更新)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-13T13:27:17+08:00">
                2018-07-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="知识点总结-不定时更新"><a href="#知识点总结-不定时更新" class="headerlink" title="知识点总结(不定时更新)"></a>知识点总结(不定时更新)</h1><h2 id="2018-07-12"><a href="#2018-07-12" class="headerlink" title="2018-07-12"></a>2018-07-12</h2><h3 id="数据库事务四个特性"><a href="#数据库事务四个特性" class="headerlink" title="数据库事务四个特性"></a>数据库事务四个特性</h3><p>ACID</p>
<ul>
<li>原子性（Atomicity）： 操作要么全部完成，要么全部回滚。</li>
<li>一致性（Consistency）： 事务使数据库的一个一致性状态变为另一个一致性状态，事务执行不改变数据库一致性。</li>
<li>隔离性（Isolation）： 多用户事务并发访问事务之间隔离。</li>
<li>持久性（Durability）： 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。</li>
</ul>
<h3 id="mysql四个隔离级别"><a href="#mysql四个隔离级别" class="headerlink" title="mysql四个隔离级别"></a>mysql四个隔离级别</h3><ul>
<li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li>
<li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li>
<li>Read committed (读已提交)：可避免脏读的发生。</li>
<li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li>
</ul>
<p><strong>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</strong></p>
<p><strong>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</strong></p>
<p><strong>幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</strong></p>
<p><strong>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</strong></p>
<p><strong>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</strong></p>
<h3 id="InnoDB与MyISAM区别"><a href="#InnoDB与MyISAM区别" class="headerlink" title="InnoDB与MyISAM区别"></a>InnoDB与MyISAM区别</h3><ul>
<li>InnoDB支持外键，MyISAM不支持</li>
<li>InnoDB支持行锁，MyISAM不支持</li>
<li>MyISAM支持全文搜索</li>
<li>InnoDB支持事务处理</li>
<li>InnoDB跨平台可以直接拷贝，MyISAM不支持</li>
<li>InnoDB表很难被压缩，MyISAM可以被压缩</li>
</ul>
<p>选择： 因为MyISAM相对简单所以在效率上要优于InnoDB.如果系统读多，写少。对原子性要求低。那么MyISAM最好的选择。且MyISAM恢复速度快。可直接用备份覆盖恢复。<br>如果系统读少，写多的时候，尤其是并发写入高的时候。InnoDB就是首选了。</p>
<h3 id="JAVA内存堆栈"><a href="#JAVA内存堆栈" class="headerlink" title="JAVA内存堆栈"></a>JAVA内存堆栈</h3><ul>
<li>栈主要储存简单的变量，如int， string等基本类型，而函数和对象和数组存在堆中，使用引用赋值。</li>
<li>使用new的对象直接保存在堆中</li>
<li>栈由系统分配，程序员分配堆，JVM垃圾回收机制回收堆内存，栈使用完成立即释放。</li>
<li>引用传递function(ref int a)直接传递内存地址，局部变量a的操作会改变内存，数组char[n]传递为引用传递</li>
<li>int a = 1; b = a； unset(a) b依然存在，因为先开辟了“1”的内存空间然后使a指向“1”的空间，然后使b指向“1”的内存空间，当unset(a)时，b仍然指向1。</li>
</ul>
<h3 id="JavaScript闭包"><a href="#JavaScript闭包" class="headerlink" title="JavaScript闭包"></a>JavaScript闭包</h3><ul>
<li>调用闭包函数访问外层变量，闭包外函数变量常住内存</li>
</ul>
<h3 id="传递赋值与引用赋值"><a href="#传递赋值与引用赋值" class="headerlink" title="传递赋值与引用赋值"></a>传递赋值与引用赋值</h3><pre><code>var a = 30;
var b = a;
a = 20;
console.log( b )   // 30

var a = [1,2];
var b = a;
a[0] = 5;
console.log( b )  // [5,2]
</code></pre><ul>
<li><p>number,string类型都是基本类型，而基本类型存放在栈区，访问时按值访问，赋值是按照普通方式赋值；</p>
</li>
<li><p>对象和数组是通过引用来赋值的，所以改变a的同时b也会跟着改变。</p>
</li>
</ul>
<h2 id="2018-07-14"><a href="#2018-07-14" class="headerlink" title="2018-07-14"></a>2018-07-14</h2><h3 id="排序算法相关"><a href="#排序算法相关" class="headerlink" title="排序算法相关"></a>排序算法相关</h3><p><strong>归并排序、冒泡排序、插入排序、基数排序是稳定的</strong></p>
<p><strong>选择排序、快速排序、希尔排序、堆排序是不稳定的</strong></p>
<ul>
<li>冒泡    平均O(n2）  最大O(n2)     稳定     n小时较好</li>
<li>选择    平均O(n2)   最大O(n2)    不稳定    n小时较好</li>
<li>插入    平均O(n2)    最大O(n2)    稳定    大部分已排序时较好</li>
<li>快速    平均小O(nlogn)     最大O(n2)    不稳定    n大时较好</li>
<li>归并    平均小O(nlogn)     最大O(nlogn)    稳定        n大时较好</li>
<li>堆     平均O(nlogn)     最大O(nlogn)    不稳定    n大时较好</li>
</ul>
<p><a href="https://www.cnblogs.com/dll-ft/p/5861210.html" target="_blank" rel="external">排序思想</a></p>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>ECMA数组大小可调整，当把一个值放在超出当前数组大小的位置上时，数组就会重新计算长度值，即长度值等于最后一项的索引加一，前面的值都自动被赋值为了undefined了。</p>
<p>相同的域：域名，协议，端口都相同</p>
<p>if (obj) 等价于 if (toBoolean(obj)) 而不是If (obj != null )</p>
<h3 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h3><ul>
<li>行内元素有：a b span img input select strong </li>
<li>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p</li>
<li>常见的空元素： <br\> <hr\> <img\> <input\> <link\> <meta\></meta\></link\></input\></img\></hr\></br\></li>
</ul>
<h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p>php 支持一个错误控制运算符：@。当将其放置在一个 php 表达式之前，该表达式可能产生的任何错误信息都被忽略掉</p>
<p>php实例化类无参数可不带括号</p>
<p>对关联数组新增不带键的元素，若前面的元素有数字（或数字字符）键，新增元素的键为前面最大的数字加1。若前面的元素无数字键，新增元素的键为0。</p>
<p>bool  empty  (  mixed $var )<br>如果 var 是非空或非零的值，则  empty()  返回 FALSE。换句话说，””、0、”0”、NULL、FALSE、array()、var $var; 以及没有任何属性的对象都将被认为是空的，如果 var 为空，则返回 TRUE。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归是栈实现的。栈是先进后出,也就是上次递归调用的时候,保存在栈顶</p>
<p>递归次数可使用多项式展开思想</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>final 变量：</p>
<p>final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。</p>
<p>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p>
<p>final 方法：</p>
<p>类中的 final 方法可以被子类继承，但是不能被子类修改。</p>
<p>声明 final 方法的主要目的是防止该方法的内容被修改。</p>
<p>如下所示，使用 final 修饰符声明方法。</p>
<p>final 类：</p>
<p>final 类不能被继承，没有类能够继承 final 类的任何特性。</p>
<p>==强调栈中的比较，可以理解为地址比较<br>，equals强调对象的内容比较</p>
<p>子类的构造方法总是先调用父类的构造方法，如果子类的构造方法没有明显地指明使用父类的哪个构造方法，子类就调用父类不带参数的构造方法。子类的构造方法的第一行隐式的默认调用父类的无参构造器即super()</p>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>DDL：数据库模式定义语言，关键字：create</p>
<p>DML：数据操纵语言，关键字：Insert、delete、update</p>
<p>DCL：数据库控制语言 ，关键字：grant、remove</p>
<p>DQL：数据库查询语言，关键字：select</p>
<p>当要删除的记录在数据库中不存在的时候，是不会报错的。</p>
<p>HAVING子句在聚合后对组记录进行筛选，HAVING在查询语句中必须依赖于GROUP BY</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树的性质</p>
<p>性质1：二叉树第i层上的结点数目最多为2^(i-1)(i&gt;=1)</p>
<p>性质2：深度为k的二叉树至多有2^k-1个结点（k&gt;=1） 至少k个</p>
<p>性质3：包含n个结点的二叉树的高度至少为(log2n)+1</p>
<p>性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1</p>
<p>性质5：如果一棵完全二叉树的结点总数为n，那么叶子结点等于n</p>
<p>（当n为偶数时）或者(n+1)/2（当n为奇数时）</p>
<p>先序遍历：（1）访问根节点；（2）采用先序递归遍历左子树；（3）采用先序递归遍历右子树；</p>
<p>中序遍历：（1）采用中序遍历左子树；（2）访问根节点；（3）采用中序遍历右子树</p>
<p>后序遍历：（1）采用后序递归遍历左子树；（2）采用后序递归遍历右子树；（3）访问根节点；</p>
<h2 id="2018-07-19"><a href="#2018-07-19" class="headerlink" title="2018-07-19"></a>2018-07-19</h2><h3 id="JavaScript-1"><a href="#JavaScript-1" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>alert(undefined==null)        true</p>
<p>alert(undefined===null)      false</p>
<p>alert(null==undefined)        true</p>
<p>alert(null===undefined)      false</p>
<ul>
<li>var self = this; self变量先保存外部函数指向的变量，当执行到函数内部this就会指向内部函数，可能会出现undefined，所以内部函数调用外部变量应该是用self。</li>
<li>使用var声明变量，在方法内部是局部变量，在方法外部是全局变量</li>
<li>没有使用var声明的变量，在方法内部或外部都是全局变量，但如果是在方法内部声明，在方法外部使用之前需要先调用包含变量的方法，告知系统声明了全局变量后方可在方法外部使用。</li>
<li>var let const区别：<ul>
<li>const定义的变量不可以修改，而且必须初始化。</li>
<li>var定义的变量可以修改，如果不初始化会输出undefined，不会报错。</li>
<li>let是块级作用域，函数内部使用let定义后，对函数外部无影响。</li>
<li><strong>变量提升</strong>：无论var变量在函数何处，执行时都会被提升到函数最上部（不会出现error，但是可能会出现undefined）</li>
<li>let为块级作用域，使用{}划分，不能跨块访问</li>
</ul>
</li>
</ul>
<p>坑：</p>
<pre><code>console.log(a);//undefined

var a = &quot;hey I am now hoisting&quot;;
</code></pre><p>相当于</p>
<pre><code>var a;
console.log(a);//undefined

a = &quot;hey I am now hoisting&quot;
</code></pre><p><strong>变量提升指的是变量声明的提升，不会提升变量的初始化和赋值。</strong></p>
<p><strong>ProtoType的使用</strong></p>
<pre><code> var dom = function(){

};

dom.Show = function(){
    alert(&quot;Show Message&quot;);
};

dom.prototype.Display = function(){
    alert(&quot;Property Message&quot;);
};

dom.Display(); //error
dom.Show();  
var d = new dom();
d.Display();
d.Show(); //error
</code></pre><ol>
<li>不使用prototype属性定义的对象方法，是静态方法，只能直接用类名进行调用！另外，此静态方法中无法使用this变量来调用对象其他的属性！
　　 </li>
<li>使用prototype属性定义的对象方法，是非静态方法，只有在实例化后才能使用！其方法内部可以this来引用对象自身中的其他属性！</li>
</ol>
<p>作用域</p>
<pre><code>var dom = function(){
    var Name = &quot;Default&quot;;
    this.Sex = &quot;Boy&quot;;
    this.success = function(){
        alert(&quot;Success&quot;);
    };
};

alert(dom.Name);
alert(dom.Sex);
</code></pre><p>两个都显示Undefined,为什么呢？这是由于在Javascript中每个function都会形成一个作用域，而这些变量声明在函数中，所以就处于这个函数的作用域中，外部是无法访问的。要想访问变量，就必须new一个实例出来。</p>
<p><a href="https://www.cnblogs.com/yunfeifei/p/4019504.html" target="_blank" rel="external">推荐博客</a></p>
<h2 id="2018-07-20"><a href="#2018-07-20" class="headerlink" title="2018-07-20"></a>2018-07-20</h2><h3 id="JavaScript-2"><a href="#JavaScript-2" class="headerlink" title="JavaScript"></a>JavaScript</h3><p><strong>重中之重： 只有函数能创建作用域，其他的都不行</strong></p>
<p><strong>if()，for()等块语句，在块语句内部定义的变量会保留在它们已经存在的作用域内</strong></p>
<p><strong>ES6特性</strong><br><a href="https://www.jianshu.com/p/287e0bb867ae" target="_blank" rel="external">blog</a></p>
<p>object.call: 函数内部this指向了call或者apply指定的对象<br><a href="https://www.jianshu.com/p/00dc4ad9b83f" target="_blank" rel="external">call,bind,apply的使用</a></p>
<p>原型链及闭包理解<br><a href="http://www.cnblogs.com/wangfupeng1988/p/3979290.html" target="_blank" rel="external">blog</a></p>
<h2 id="2018-07-12-1"><a href="#2018-07-12-1" class="headerlink" title="2018-07-12"></a>2018-07-12</h2><h3 id="JavaScript-3"><a href="#JavaScript-3" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>this关键字指向：</p>
<ul>
<li>如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。平时为window对象</li>
<li>如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象。如果函数被赋值到了另一个变量中(var f = var.fn();fn();)，并没有作为obj的一个属性被调用，那么this的值就是window。</li>
<li>函数作为对象属性内部定义函数中的this指向window</li>
</ul>
<p><strong>作用域</strong></p>
<p>javascript除了全局作用域之外，只有函数可以创建的作用域。</p>
<p><img src="https://images0.cnblogs.com/blog/138012/201409/241708372951952.png" alt="作用域"></p>
<p>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。</p>
<p>JS闭包</p>
<p>闭包的作用</p>
<pre><code>        function f1(){
        var n =1;

        return function(){
            alert(n)
        }; } 
var result = f1(); result();//1
</code></pre><p>  1：读取函数内部的变量</p>
<p>就如上面闭包的例子，可以在函数外部读取函数内部的变量。</p>
<p>  2：将变量的值始终保存在内存中</p>
<p>一般来讲，当函数执行完毕之后，函数内部的局部活动对象就会被销毁，内存中仅保存全局作用域，即js的内存回收机制。如果这个函数内部又嵌套了另一个函数,而这个函数是有可能在外部被调用到的.并且这个内部函数又使用了外部函数的某些变量的话.这种内存回收机制就会出现问题。如果在外部函数返回后,又直接调用了内部函数,那么内部函数就无法读取到他所需要的外部函数中变量的值了.所以js解释器在遇到函数定义的时候,会自动把函数和他可能使用的变量(包括本地变量和父级和祖先级函数的变量(自由变量))一起保存起来.也就是构建一个闭包,这些变量将不会被内存回收器所回收,只有当内部的函数不可能被调用以后(例如被删除了,或者没有了指针),才会销毁这个闭包,而没有任何一个闭包引用的变量才会被下一次内存回收启动时所回收。</p>
<p>坑：</p>
<pre><code>function createFunction(){
    var result = new Array();
    for( var i = 0; i &lt;10; i++){
        result[i] = function(){
            return i;
        };
    }
    return result;
}
var aa = createFunction();
alert(aa[0]());//10
alert(aa[1]());//10
</code></pre><p>在这个函数中，我们直接将闭包赋值给数组。这个函数会返回一个函数数组。表面上来看，似乎每个函数都应该返回自己的索引，即位置0的函数返回0，位置1的函数返回1一次类推。但实际上，如同上面例子，每个函数都返回了10。<strong>因为每个函数的作用域链中都保存createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()函数返回后，变量i的值死10，此时每个函数都引用着保存变量i的同一个变量对象。所以在每个函数内部i的值都是10。</strong></p>
<p>所以，我们可以通过如下例子，创建一个自执行函数（匿名函数）强制让闭包的行为符合预期。</p>
<pre><code>function createFunction1(){
     var result = new Array();
     for( var i = 0; i &lt;10; i++){
         result[i] = function(num){
             return function(){
                 return num;
             };
         }(i);
     }
     return result;
 }

 var bb = createFunction1();
 alert(bb[0]());//0
 alert(bb[1]());//1
</code></pre><p>从createFunctions1()这个函数的执行结果来看，每个函数都返回各自不同的索引值了，是什么原因呢？<br>在createFunctions1()这个函数中，我们没有直接将闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋值给数组。<strong>对于立即执行的匿名函数来说，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放。</strong>所以这里的匿名函数有一个参数num，也就是最终的函数要返回的值。在调用每个匿名函数时，我们传入了变量i。由于函数是按值传递的，所以会将变量i的当前值赋值给参数num，而这个匿名函数内部，又创建并返回了一个返回num的闭包。这样一来，result数组中的每个函数都有自己num的一个副本，因此就可以返回各自不同的数值了。</p>
<p>作用域链取值：</p>
<p><img src="https://images0.cnblogs.com/blog/138012/201409/251447377485132.png" alt="作用域链取值"></p>
<p><strong>要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”</strong></p>
<p>作用域链查找过程：</p>
<p>第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续；</p>
<p>第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；</p>
<p>第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；</p>
<p>第四步，跳转到第一步。</p>
<p><img src="https://images0.cnblogs.com/blog/138012/201409/251448515607115.png" alt=""></p>
<ul>
<li>箭头函数特性:箭头函数的this其实就是在定义的时候就确定好的，以后不管怎么调用这个箭头函数，箭头函数的this始终为定义时的this </li>
</ul>
<h2 id="2018-07-24"><a href="#2018-07-24" class="headerlink" title="2018-07-24"></a>2018-07-24</h2><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><p>线程状态</p>
<ul>
<li>新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();</li>
<li>就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，<strong>并不是说执行了t.start()此线程立即就会执行；</strong></li>
<li>运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</li>
<li><p>阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p>
<ul>
<li>等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</li>
<li>同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</li>
<li>其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
</ul>
</li>
<li><p>死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>
</li>
</ul>
<p>sleep和wait的区别</p>
<ul>
<li>每个对象都有一个锁来控制同步访问，Synchronized关键字可以和对象的锁交互，来实现同步方法或同步块。执行sleep()方法后正在执行的线程主动让出CPU（然后CPU就可以去执行其他任务），在sleep指定时间后CPU再回到该线程继续往下执行(<strong>注意：sleep方法只让出了CPU，而并不会释放同步资源锁！！！</strong>)；wait()方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，<strong>只有调用了notify()方法，之前调用wait()的线程才会解除wait状态</strong>，可以去参与竞争同步资源锁，进而得到执行。（注意：notify的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说notify只是让之前调用wait的线程有权利重新参与线程的调度）；</li>
<li>sleep()方法可以在任何地方使用；wait()方法则只能在同步方法或同步块中使用；</li>
<li>sleep()是线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait()是Object的方法，调用会放弃对象锁，进入等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才会进入锁池，再次获得对象锁才会进入运行状态；</li>
</ul>
<p>线程安全</p>
<ul>
<li>Vector  HashTable  StringBuffer  statck enumeration是线程安全的.</li>
<li>ArrayList、 LinkedList、HashMap、StringBuilder 是非线程安全的。</li>
</ul>
<p>死锁</p>
<p> 产生死锁的原因主要是：</p>
<p>o   1） 因为系统资源不足。</p>
<p>o   2） 进程运行推进的顺序不合适。</p>
<p>o   3） 资源分配不当等。    </p>
<p>·     导致死锁的4个必要条件：</p>
<p>o   1、互斥条件。一次只有一个进程可以使用一个资源。其他进程不能访问已分配给其他进程的资源。</p>
<p>o   2、请求保持条件。当一个进程等待其他进程时，继续占有已经分配的资源。</p>
<p>o   3、不可剥夺条件。不能强行抢占进程已占有的资源。</p>
<p>o   4、循环等待条件。存在一个封闭的进程链，使得每个进程至少占有此链中下一个进程所需要的一个资源。</p>
<p><strong>synchronized</strong></p>
<p>当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。</p>
<p>o   一、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</p>
<p>o   二、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。</p>
<p>o   三、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。</p>
<p>o    四、第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。</p>
<p>HashMap</p>
<p>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Factor(负载因子)则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p>
<p>当key出现hash冲突的时候,链表中的第一个元素都是后面最新添加进来的那个,之前的则被next变量引用着。虽然这里是插入的动作,但是由于使用了链表,所以无需像数组的插入那样,进行数组拷贝。</p>
<p>ArrayList 和 LinkList</p>
<p>ArrayList与linkedList在性能上各有优缺点，都有各自的地方，</p>
<p>1.对ArrayList和LinkedList而言，在列表中末尾添加一个元素所花的开销是固定的</p>
<p>2.在ArrayList中间插入一个元素或删除一个元素意味着整个列表中剩余的元素都会移动，而LinkedList的中间插入或删除一个元素的开销是固定的</p>
<p>3.LinkedList不支持高效的随机访问</p>
<p> 可以这样说：当操作是在一列数据后面添加数据而不是在前面或中间，并且是随机访问其中元素时，使用arrayList会提供比较好的性能；当你操作是在一列数据的前面或中间添加或删除数据，并不是按照顺序访问其中的元素，就应该使用LinkedList了</p>
<p>线程 join</p>
<p>主线程(我在“一”里已经命名过了)等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。(Waits for this thread to die.)</p>
<p>乐观锁</p>
<p> 总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现。</p>
<p>悲观锁</p>
<p> 总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。</p>
<p>Synchronized与ReentrantLock的区别</p>
<p>对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成。</p>
<h2 id="2018-07-25"><a href="#2018-07-25" class="headerlink" title="2018-07-25"></a>2018-07-25</h2><h3 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h3><p>美团Java2018面试模拟题</p>
<ul>
<li><p>try{}语句块内不论有错误还是有return都会执行finally语句块，但下面的语句块不会再执行</p>
</li>
<li><p>RuntimeException 使用try{}，catc{}捕获不是必须的</p>
</li>
<li><p>sleep()方法并不会让出cpu</p>
</li>
<li><p>如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承</p>
</li>
<li>finally在异常处理时提供 finally 块来执行任何清除操作</li>
<li>Java使用 finalize() 方法在垃圾收集器象从内存中清除出去之前做必要的清理工作</li>
<li>static{}静态代码块首先执行，即，静态代码块-&gt;非静态代码块-&gt;构造器</li>
<li>Object类中没有copy方法</li>
<li>接口只能用public修饰，并且是抽象的；其中只能是抽象方法</li>
<li>子类不能继承父类构造方法，一个子类只能继承一个父类</li>
<li>构造方法是一种特殊的方法，它是一个与类同名且没有返回值类型的方法。</li>
<li>int 和Integer在进行比较的时候，Integer会进行拆箱，转为int值与int进行比较。整Integer字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象</li>
<li>Integer i01 = 59，java在编译的时候,被翻译成-&gt; Integer i01 = Integer.valueOf(59);</li>
<li>初始化时int类的变量初始为0.而Integer的变量则初始化为null.</li>
<li>自动装箱:Integer字面量的值在-128到127之间, Integer a = 127;相当于Integer a = new Integer(127)</li>
<li>方法中的<strong>局部变量</strong>，存放在栈区,类中的<strong>成员变量</strong>，存放在堆区</li>
<li>JAVA语言不允许程序员直接控制内存空间的使用。内存空间的分配和回收都是由JRE负责在后台自动进行的，尤其是无用内存空间的回收操作 (garbagecollection,也称垃圾回收)，只能由运行环境提供的一个超级线程进行监测和控制。</li>
</ul>
<h2 id="2018-07-25-1"><a href="#2018-07-25-1" class="headerlink" title="2018-07-25"></a>2018-07-25</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>redis相比memcached有哪些优势？ 　　</p>
<p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 </p>
<p>(2) redis的速度比memcached快很多</p>
<p>(3) redis可以持久化其数据</p>
<p>Memcache与Redis的区别都有哪些？<br>1)、存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，这样能保证数据的持久性。 </p>
<p>2)、数据支持类型 Memcache对数据类型支持相对简单。 Redis有复杂的数据类型。 </p>
<p>3)、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 </p>
<p>为什么redis需要把所有数据放到内存中?　</p>
<p>　　　Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。</p>
<p>　　　如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>
<p><strong>和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。</strong></p>
<p>redis支持主从的模式。原则：Master会将数据同步到slave，而slave不会将数据同步到master。Slave启动时会连接master来同步数据。</p>
<p>这是一个典型的分布式读写分离模型。我们可以利用master来插入数据，slave提供检索服务。这样可以有效减少单个机器的并发访问数量</p>
<p> Redis 常见的性能问题都有哪些？如何解决？</p>
<p>1).Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。</p>
<p>2).Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</p>
<p>3).Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</p>
<p>4). Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</p>
<h3 id="SQL-1"><a href="#SQL-1" class="headerlink" title="SQL"></a>SQL</h3><p>SQL的join</p>
<pre><code>select column_name(s)
from table 1
INNER JOIN table 2
ON
table 1.column_name=table 2.column_name
</code></pre><p><img src="https://images2017.cnblogs.com/blog/1074709/201712/1074709-20171229165319538-1026266241.png" alt="innerjoin"></p>
<p>INNER JOIN产生的结果集中，是1和2的交集。</p>
<p><img src="https://images2017.cnblogs.com/blog/1074709/201712/1074709-20171229170434726-2010021622.png" alt=""></p>
<p>LEFT JOIN产生表1的完全集，而2表中匹配的则有值，没有匹配的则以null值取代。</p>
<p><img src="https://images2017.cnblogs.com/blog/1074709/201712/1074709-20171229171503867-2027149651.png" alt=""></p>
<p>RIGHT JOIN产生表2的完全集，而1表中匹配的则有值，没有匹配的则以null值取代。</p>
<p><img src="https://images2017.cnblogs.com/blog/1074709/201712/1074709-20171229172802179-389908324.png" alt=""></p>
<p>FULL OUTER JOIN产生1和2的并集。但是需要注意的是，对于没有匹配的记录，则会以null做为值。</p>
<p><strong>关键字: on</strong></p>
<p>数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。</p>
<p>在使用left jion时，on和where条件的区别如下：</p>
<p>1、 on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。</p>
<p>2、where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</p>
<p><strong>SQL优化</strong></p>
<ul>
<li>选取最适用的字段属性，尽量把字段设置为NOTNULL</li>
<li>使用连接（JOIN）来代替子查询(Sub-Queries)，连接（JOIN）..之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</li>
<li>使用联合(UNION)来代替手动创建的临时表</li>
<li>使用索引，一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况，在建有索引的字段上尽量不要使用函数进行操作。</li>
</ul>
<h3 id="JavaScript-4"><a href="#JavaScript-4" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>跨域方式</p>
<ul>
<li>response.setHeader(“Access-Control-Allow-Origin”, “*”);</li>
<li>使用标签进行跨域</li>
<li>jsonp方式不支持POST方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。</li>
<li>后端接口返回一个带有参数的方法名，其中函数的参数为返回信息，函数名为前端的回调函数名</li>
<li>jquery如果有success函数则默认success()作为回调函数。</li>
</ul>
<p><a href="https://www.cnblogs.com/mehjb/p/6125892.html" target="_blank" rel="external">HTML面试坑</a></p>
<p>##2018-08-07</p>
<h3 id="JavaScript-5"><a href="#JavaScript-5" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>浏览器端常用储存技术：</p>
<ul>
<li>cookie</li>
<li>WebStorage(localStorage、sessionStorage)</li>
<li>UserData</li>
<li>IndexedDB</li>
</ul>
<p>块级元素与行内元素的区别</p>
<p>常用块级元素</p>
<p><img src="https://uploadfiles.nowcoder.net/images/20160731/213669_1469934373582_04341C4C965D57F74167CCE72D2EAF7B" alt="常用块级元素"></p>
<p>常用行级元素</p>
<p><img src="https://uploadfiles.nowcoder.net/images/20160731/213669_1469934384802_F3CB514AAFC503A1BCD00D1B81F87ED1" alt="常用行级元素"></p>
<ul>
<li>块级元素会独占一行，其宽度自动填满其父元素宽度；<br>行内元素不会独占一行，相邻的行内元素会排列在同一行，直至一行排不下才会换行，其宽度随元素的内容而变化。</li>
<li>块级元素可以包含行内元素和块级元素；行内元素不能包含块级元素。</li>
<li>行内元素设置width、height、margin-top、margin-bottom、padding-top、padding-bottom无效。</li>
</ul>
<p>块级元素与行内元素的转换</p>
<ul>
<li>display:inline-block;</li>
<li>display:inline;</li>
<li>display:block;</li>
</ul>
<p>JavaScript内部对象</p>
<ul>
<li>History 对象包含用户（在浏览器窗口中）访问过的 URL</li>
<li>Location 对象包含有关当前 URL 的信息</li>
<li>Window 对象表示浏览器中打开的窗口</li>
<li>Navigator 对象包含有关浏览器的信息</li>
</ul>
<p>常用的页面的图片格式有三种，GIF、JPG、PNG</p>
<h3 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h3><p>Byte范围是-128~127 127+1=-128</p>
<p>构造器没有返回类型，并不是void</p>
<p>Java一个源程序只能有一个public类存在，且类名与文件名相同.</p>
<p>当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</p>
<p>抽象类：</p>
<ul>
<li>抽象类不能实例化，因为有抽象方法未实现</li>
<li>可以被继承。派生类可以实现抽象方法</li>
<li>子类可以是抽象的，也可以非抽象的</li>
<li>可以被抽象类继承，也可以被非抽象类继承</li>
</ul>
<p>Java类成员的访问控制权限：<br>public &gt; protected &gt; 同包（default） &gt; private</p>
<p><img src="https://uploadfiles.nowcoder.net/images/20170623/2527957_1498180954324_D83CBF646B3F43FE947460F6D7231780" alt=""></p>
<p>子类重写父类方法，调用时会调用子类重写之后的方法，包括父类构造器中调用父类的方法会变成重载后子类的方法，注意实例化顺序</p>
<p>Java.awt.*只能导入awt这个包中的所有类，awt中的包中的类不会导入</p>
<p>执行 Base b = new Sub();时由于多态 b编译时表现为Base类特性，运行时表现为Sub类特性，编译看左边，运行看右边。</p>
<p>内部类其实和类的属性没什么区别，只是在声明的时候必须是Outer.Inner a</p>
<h3 id="PHP-1"><a href="#PHP-1" class="headerlink" title="PHP"></a>PHP</h3><p>unset($a)相当于对$a变量内存引用-1，如果引用为0才回收内存。</p>
<p>如果不设置cookie结束时间，他会在关闭浏览器的时候销毁</p>
<p>php和Java不同，Java中类属性是可以用final修饰表示的是常量，PHP不能，因为PHP的常量只能用define定义。</p>
<ul>
<li>final—用于类、方法前。  </li>
<li>final类—不可被继承。  </li>
<li>final方法—不可被覆盖。</li>
</ul>
<h2 id="2018-08-08"><a href="#2018-08-08" class="headerlink" title="2018-08-08"></a>2018-08-08</h2><h3 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h3><p>已知一棵二叉树的前序序列和中序序列，构造该二叉树的过程如下：</p>
<ol>
<li>根据前序序列的第一个元素建立根结点；</li>
<li>在中序序列中找到该元素，确定根结点的左右子树的中序序列；</li>
<li>在前序序列中确定左右子树的前序序列；</li>
<li>由左子树的前序序列和中序序列建立左子树；</li>
<li>由右子树的前序序列和中序序列建立右子树。</li>
</ol>
<p>已知一棵二叉树的后序序列和中序序列，构造该二叉树的过程如下：</p>
<ol>
<li>根据后序序列的最后一个元素建立根结点；</li>
<li>在中序序列中找到该元素，确定根结点的左右子树的中序序列；</li>
<li>在后序序列中确定左右子树的后序序列；</li>
<li>由左子树的后序序列和中序序列建立左子树；</li>
<li>由右子树的后序序列和中序序列建立右子树。</li>
</ol>
<p>只给出先序遍历和后序遍历不能唯一确定二叉树的例子</p>
<p>二叉树分类：</p>
<ul>
<li><p>满二叉树: 除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充。</p>
</li>
<li><p>完全二叉树: 除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐。</p>
</li>
</ul>
<p>完全二叉书&lt;满二叉树</p>
<p><strong>二叉排序树</strong>:</p>
<p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p>
<p>（1）若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；</p>
<p>（2）若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</p>
<p>（3）左、右子树也分别为二叉排序树；</p>
<p>（4）二叉排序树中序遍历为从大到小的顺序；</p>
<p><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=ea3d88e2269759ee4a5067cd8ac0242b/94cad1c8a786c9179df9bed6c93d70cf3ac75763.jpg" alt="二叉排序树"></p>
<p>二叉排序树查找：<br>要在二叉树中找出查找最大最小元素是极简单的事情，从根节点一直往左走，直到无路可走就可得到最小值；从根节点一直往右走，直到无路可走，就可以得到最大值。</p>
<p>二叉排序树插入：<br>插入新元素时，可以从根节点开始，遇键值较大者就向左，遇键值较小者就向右，一直到末端，就是插入点。 </p>
<p>二叉排序树删除：<br>对于二叉排序树中的节点A，对它的删除分为两种情况： </p>
<ul>
<li>如果A只有一个子节点，就直接将A的子节点连至A的父节点上，并将A删除；</li>
<li>如果A有两个子节点，我们就以右子树内的最小节点取代A</li>
</ul>
<p><strong>平衡二叉树</strong>：</p>
<p>【平衡特性1】：左子树的深度和右子树的深度相差不能超过1</p>
<p>【平衡特性2】它的左右子树也要是平衡二叉树</p>
<p><strong>二叉线索树</strong>：</p>
<p>结点结构图：</p>
<pre><code>LChild  Ltag   Data  Rtag   RChild 
</code></pre><p>如果有左孩子，则LChild继续指向左孩子，否则，指向该结点的前驱结点。</p>
<p>如果有右孩子，则RChild继续指向右孩子，否则，指向该结点的后继结点。</p>
<p>Ltag 用来标记是 左孩子（Ltag = 0）还是 前驱结点 （Ltag = 1）</p>
<p>Rtag 用来标记是 右孩子(Rtag = 0) 还是 后继结点  (Rtag = 1)</p>
<p>前驱节点</p>
<ul>
<li>若一个节点有左子树，那么该节点的前驱节点是其左子树中val值最大的节点</li>
<li>若一个节点没有左子树，那么判断该节点和其父节点的关系 <ul>
<li>若该节点是其父节点的右边孩子，那么该节点的前驱结点即为其父节点。 </li>
<li>若该节点是其父节点的左边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的右边孩子，那么Q就是该节点的前驱</li>
</ul>
</li>
</ul>
<p>后继节点（类比前驱结点）</p>
<ul>
<li>若一个节点有右子树，那么该节点的后继节点是其右子树中val值最小的节点</li>
<li>若一个节点没有右子树，那么判断该节点和其父节点的关系 <ul>
<li>若该节点是其父节点的左边孩子，那么该节点的后继结点即为其父节点。 </li>
<li>若该节点是其父节点的右边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的左边孩子，那么Q就是该节点的后继节点</li>
</ul>
</li>
</ul>
<p>n结点的二叉链表共有2n个链域，非空链域为n-1个，但其中的空链域却有n+1个</p>
<h2 id="2018-08-10"><a href="#2018-08-10" class="headerlink" title="2018-08-10"></a>2018-08-10</h2><h3 id="JavaScript-6"><a href="#JavaScript-6" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>关于var作用域问题</p>
<ul>
<li><p>var定义的变量会存在变量提升，会被提升到定义它的函数顶部</p>
<pre><code>function f(){
    //some actions()
    var a = 1；
} 

等价于

function f(){
    var a //a == undefined
    //some actions()
    a = 1
}
</code></pre></li>
<li><p>不添加var定义的变量相当于全局变量，无论是在函数内还是函数外。</p>
</li>
<li><p><strong>但是有这么个情况</strong></p>
<pre><code>aa = 1；
function test (aa){
  aa = 2;
    alert(aa) //输出2
}
test(aa)
alert(aa)//输出1
</code></pre></li>
</ul>
<p><strong>看似在function中更改了全局变量2 应该输出2,2,但是function函数形参变量名仍为aa，所以相当于在函数体内隐式定义 var aa，所以函数体内aa相当于函数内局部变量，并没有修改全局aa</strong></p>
<h2 id="2018-08-11"><a href="#2018-08-11" class="headerlink" title="2018-08-11"></a>2018-08-11</h2><h3 id="JavaScript-7"><a href="#JavaScript-7" class="headerlink" title="JavaScript"></a>JavaScript</h3><p><strong>前端缓存机制</strong></p>
<p>通过header中的cache-control字段来控制前端缓存机制</p>
<ul>
<li>public 客户端与缓存代理服务器可以缓存</li>
<li>private 只能客户端进行缓存</li>
<li>expires 缓存过期时间</li>
<li>max-age 设定缓存过期时间（秒）可覆盖expires</li>
<li>no-cache 浏览器发送请求标识符到服务器做验证（协商缓存）<ul>
<li>request携带if-modified-science 与 response中的last-modified进行对比，如果last-modified &gt; if-modified-science，则从服务器返回资源，（status 200），否则使用硬盘缓存资源（status 304）</li>
</ul>
</li>
<li>no-store 浏览器不进行缓存。</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/12/Linux备注/" rel="next" title="Linux备注">
                <i class="fa fa-chevron-left"></i> Linux备注
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="zhanxu" />
          <p class="site-author-name" itemprop="name">zhanxu</p>
           
              <p class="site-description motion-element" itemprop="description">老战的程序猿成长踩坑路程</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ZX19951110" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/zhan-xu-41/activities" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://619186893.lofter.com/" target="_blank" title="Lofter">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Lofter
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#知识点总结-不定时更新"><span class="nav-number">1.</span> <span class="nav-text">知识点总结(不定时更新)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2018-07-12"><span class="nav-number">1.1.</span> <span class="nav-text">2018-07-12</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库事务四个特性"><span class="nav-number">1.1.1.</span> <span class="nav-text">数据库事务四个特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql四个隔离级别"><span class="nav-number">1.1.2.</span> <span class="nav-text">mysql四个隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB与MyISAM区别"><span class="nav-number">1.1.3.</span> <span class="nav-text">InnoDB与MyISAM区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JAVA内存堆栈"><span class="nav-number">1.1.4.</span> <span class="nav-text">JAVA内存堆栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript闭包"><span class="nav-number">1.1.5.</span> <span class="nav-text">JavaScript闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传递赋值与引用赋值"><span class="nav-number">1.1.6.</span> <span class="nav-text">传递赋值与引用赋值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2018-07-14"><span class="nav-number">1.2.</span> <span class="nav-text">2018-07-14</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#排序算法相关"><span class="nav-number">1.2.1.</span> <span class="nav-text">排序算法相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript"><span class="nav-number">1.2.2.</span> <span class="nav-text">JavaScript</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS3"><span class="nav-number">1.2.3.</span> <span class="nav-text">CSS3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PHP"><span class="nav-number">1.2.4.</span> <span class="nav-text">PHP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number">1.2.5.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java"><span class="nav-number">1.2.6.</span> <span class="nav-text">Java</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL"><span class="nav-number">1.2.7.</span> <span class="nav-text">SQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树"><span class="nav-number">1.2.8.</span> <span class="nav-text">二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2018-07-19"><span class="nav-number">1.3.</span> <span class="nav-text">2018-07-19</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">JavaScript</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2018-07-20"><span class="nav-number">1.4.</span> <span class="nav-text">2018-07-20</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-2"><span class="nav-number">1.4.1.</span> <span class="nav-text">JavaScript</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2018-07-12-1"><span class="nav-number">1.5.</span> <span class="nav-text">2018-07-12</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-3"><span class="nav-number">1.5.1.</span> <span class="nav-text">JavaScript</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2018-07-24"><span class="nav-number">1.6.</span> <span class="nav-text">2018-07-24</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JAVA"><span class="nav-number">1.6.1.</span> <span class="nav-text">JAVA</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2018-07-25"><span class="nav-number">1.7.</span> <span class="nav-text">2018-07-25</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JAVA-1"><span class="nav-number">1.7.1.</span> <span class="nav-text">JAVA</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2018-07-25-1"><span class="nav-number">1.8.</span> <span class="nav-text">2018-07-25</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis"><span class="nav-number">1.8.1.</span> <span class="nav-text">Redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL-1"><span class="nav-number">1.8.2.</span> <span class="nav-text">SQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-4"><span class="nav-number">1.8.3.</span> <span class="nav-text">JavaScript</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-5"><span class="nav-number">1.8.4.</span> <span class="nav-text">JavaScript</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-1"><span class="nav-number">1.8.5.</span> <span class="nav-text">Java</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PHP-1"><span class="nav-number">1.8.6.</span> <span class="nav-text">PHP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2018-08-08"><span class="nav-number">1.9.</span> <span class="nav-text">2018-08-08</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树-1"><span class="nav-number">1.9.1.</span> <span class="nav-text">二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2018-08-10"><span class="nav-number">1.10.</span> <span class="nav-text">2018-08-10</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-6"><span class="nav-number">1.10.1.</span> <span class="nav-text">JavaScript</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2018-08-11"><span class="nav-number">1.11.</span> <span class="nav-text">2018-08-11</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-7"><span class="nav-number">1.11.1.</span> <span class="nav-text">JavaScript</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhanxu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
