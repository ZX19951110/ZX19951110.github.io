<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老战博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zx19951110.github.io/ZX.github.io/"/>
  <updated>2018-07-26T07:47:07.125Z</updated>
  <id>https://zx19951110.github.io/ZX.github.io/</id>
  
  <author>
    <name>zhanxu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>知识点总结(不定时更新)</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2018/07/13/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2018/07/13/知识点总结-不定时更新/</id>
    <published>2018-07-13T05:27:17.000Z</published>
    <updated>2018-07-26T07:47:07.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点总结-不定时更新"><a href="#知识点总结-不定时更新" class="headerlink" title="知识点总结(不定时更新)"></a>知识点总结(不定时更新)</h1><h2 id="2018-07-12"><a href="#2018-07-12" class="headerlink" title="2018-07-12"></a>2018-07-12</h2><h3 id="数据库事务四个特性"><a href="#数据库事务四个特性" class="headerlink" title="数据库事务四个特性"></a>数据库事务四个特性</h3><p>ACID</p><ul><li>原子性（Atomicity）： 操作要么全部完成，要么全部回滚。</li><li>一致性（Consistency）： 事务使数据库的一个一致性状态变为另一个一致性状态，事务执行不改变数据库一致性。</li><li>隔离性（Isolation）： 多用户事务并发访问事务之间隔离。</li><li>持久性（Durability）： 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。</li></ul><h3 id="mysql四个隔离级别"><a href="#mysql四个隔离级别" class="headerlink" title="mysql四个隔离级别"></a>mysql四个隔离级别</h3><ul><li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li><li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li><li>Read committed (读已提交)：可避免脏读的发生。</li><li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li></ul><p><strong>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</strong></p><p><strong>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</strong></p><p><strong>幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</strong></p><p><strong>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</strong></p><p><strong>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</strong></p><h3 id="InnoDB与MyISAM区别"><a href="#InnoDB与MyISAM区别" class="headerlink" title="InnoDB与MyISAM区别"></a>InnoDB与MyISAM区别</h3><ul><li>InnoDB支持外键，MyISAM不支持</li><li>InnoDB支持行锁，MyISAM不支持</li><li>MyISAM支持全文搜索</li><li>InnoDB支持事务处理</li><li>InnoDB跨平台可以直接拷贝，MyISAM不支持</li><li>InnoDB表很难被压缩，MyISAM可以被压缩</li></ul><p>选择： 因为MyISAM相对简单所以在效率上要优于InnoDB.如果系统读多，写少。对原子性要求低。那么MyISAM最好的选择。且MyISAM恢复速度快。可直接用备份覆盖恢复。<br>如果系统读少，写多的时候，尤其是并发写入高的时候。InnoDB就是首选了。</p><h3 id="JAVA内存堆栈"><a href="#JAVA内存堆栈" class="headerlink" title="JAVA内存堆栈"></a>JAVA内存堆栈</h3><ul><li>栈主要储存简单的变量，如int， string等基本类型，而函数和对象和数组存在堆中，使用引用赋值。</li><li>使用new的对象直接保存在堆中</li><li>栈由系统分配，程序员分配堆，JVM垃圾回收机制回收堆内存，栈使用完成立即释放。</li><li>引用传递function(ref int a)直接传递内存地址，局部变量a的操作会改变内存，数组char[n]传递为引用传递</li><li>int a = 1; b = a； unset(a) b依然存在，因为先开辟了“1”的内存空间然后使a指向“1”的空间，然后使b指向“1”的内存空间，当unset(a)时，b仍然指向1。</li></ul><h3 id="JavaScript闭包"><a href="#JavaScript闭包" class="headerlink" title="JavaScript闭包"></a>JavaScript闭包</h3><ul><li>调用闭包函数访问外层变量，闭包外函数变量常住内存</li></ul><h3 id="传递赋值与引用赋值"><a href="#传递赋值与引用赋值" class="headerlink" title="传递赋值与引用赋值"></a>传递赋值与引用赋值</h3><pre><code>var a = 30;var b = a;a = 20;console.log( b )   // 30var a = [1,2];var b = a;a[0] = 5;console.log( b )  // [5,2]</code></pre><ul><li><p>number,string类型都是基本类型，而基本类型存放在栈区，访问时按值访问，赋值是按照普通方式赋值；</p></li><li><p>对象和数组是通过引用来赋值的，所以改变a的同时b也会跟着改变。</p></li></ul><h2 id="2018-07-14"><a href="#2018-07-14" class="headerlink" title="2018-07-14"></a>2018-07-14</h2><h3 id="排序算法相关"><a href="#排序算法相关" class="headerlink" title="排序算法相关"></a>排序算法相关</h3><p><strong>归并排序、冒泡排序、插入排序、基数排序是稳定的</strong></p><p><strong>选择排序、快速排序、希尔排序、堆排序是不稳定的</strong></p><ul><li>冒泡    平均O(n2）  最大O(n2)     稳定     n小时较好</li><li>选择    平均O(n2)   最大O(n2)    不稳定    n小时较好</li><li>插入    平均O(n2)    最大O(n2)    稳定    大部分已排序时较好</li><li>快速    平均小O(nlogn)     最大O(n2)    不稳定    n大时较好</li><li>归并    平均小O(nlogn)     最大O(nlogn)    稳定        n大时较好</li><li>堆     平均O(nlogn)     最大O(nlogn)    不稳定    n大时较好</li></ul><p><a href="https://www.cnblogs.com/dll-ft/p/5861210.html" target="_blank" rel="external">排序思想</a></p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>ECMA数组大小可调整，当把一个值放在超出当前数组大小的位置上时，数组就会重新计算长度值，即长度值等于最后一项的索引加一，前面的值都自动被赋值为了undefined了。</p><p>相同的域：域名，协议，端口都相同</p><p>if (obj) 等价于 if (toBoolean(obj)) 而不是If (obj != null )</p><h3 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h3><ul><li>行内元素有：a b span img input select strong </li><li>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p</li><li>常见的空元素： <br\> <hr\> <img\> <input\> <link\> <meta\></meta\></link\></input\></img\></hr\></br\></li></ul><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p>php 支持一个错误控制运算符：@。当将其放置在一个 php 表达式之前，该表达式可能产生的任何错误信息都被忽略掉</p><p>php实例化类无参数可不带括号</p><p>对关联数组新增不带键的元素，若前面的元素有数字（或数字字符）键，新增元素的键为前面最大的数字加1。若前面的元素无数字键，新增元素的键为0。</p><p>bool  empty  (  mixed $var )<br>如果 var 是非空或非零的值，则  empty()  返回 FALSE。换句话说，””、0、”0”、NULL、FALSE、array()、var $var; 以及没有任何属性的对象都将被认为是空的，如果 var 为空，则返回 TRUE。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归是栈实现的。栈是先进后出,也就是上次递归调用的时候,保存在栈顶</p><p>递归次数可使用多项式展开思想</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>final 变量：</p><p>final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。</p><p>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p><p>final 方法：</p><p>类中的 final 方法可以被子类继承，但是不能被子类修改。</p><p>声明 final 方法的主要目的是防止该方法的内容被修改。</p><p>如下所示，使用 final 修饰符声明方法。</p><p>final 类：</p><p>final 类不能被继承，没有类能够继承 final 类的任何特性。</p><p>==强调栈中的比较，可以理解为地址比较<br>，equals强调对象的内容比较</p><p>子类的构造方法总是先调用父类的构造方法，如果子类的构造方法没有明显地指明使用父类的哪个构造方法，子类就调用父类不带参数的构造方法。子类的构造方法的第一行隐式的默认调用父类的无参构造器即super()</p><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>DDL：数据库模式定义语言，关键字：create</p><p>DML：数据操纵语言，关键字：Insert、delete、update</p><p>DCL：数据库控制语言 ，关键字：grant、remove</p><p>DQL：数据库查询语言，关键字：select</p><p>当要删除的记录在数据库中不存在的时候，是不会报错的。</p><p>HAVING子句在聚合后对组记录进行筛选，HAVING在查询语句中必须依赖于GROUP BY</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树的性质</p><p>性质1：二叉树第i层上的结点数目最多为2i-1(i&gt;=1)</p><p>性质2：深度为k的二叉树至多有2k-1个结点（k&gt;=1）</p><p>性质3：包含n个结点的二叉树的高度至少为(log2n)+1</p><p>性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1</p><p>性质5：如果一棵完全二叉树的结点总数为n，那么叶子结点等于n/2（当n为偶数时）或者(n+1)/2（当n为奇数时）</p><p>先序遍历：（1）访问根节点；（2）采用先序递归遍历左子树；（3）采用先序递归遍历右子树；</p><p>中序遍历：（1）采用中序遍历左子树；（2）访问根节点；（3）采用中序遍历右子树</p><p>后序遍历：（1）采用后序递归遍历左子树；（2）采用后序递归遍历右子树；（3）访问根节点；</p><h2 id="2018-07-19"><a href="#2018-07-19" class="headerlink" title="2018-07-19"></a>2018-07-19</h2><h3 id="JavaScript-1"><a href="#JavaScript-1" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>alert(undefined==null)        true</p><p>alert(undefined===null)      false</p><p>alert(null==undefined)        true</p><p>alert(null===undefined)      false</p><ul><li>var self = this; self变量先保存外部函数指向的变量，当执行到函数内部this就会指向内部函数，可能会出现undefined，所以内部函数调用外部变量应该是用self。</li><li>使用var声明变量，在方法内部是局部变量，在方法外部是全局变量</li><li>没有使用var声明的变量，在方法内部或外部都是全局变量，但如果是在方法内部声明，在方法外部使用之前需要先调用包含变量的方法，告知系统声明了全局变量后方可在方法外部使用。</li><li>var let const区别：<ul><li>const定义的变量不可以修改，而且必须初始化。</li><li>var定义的变量可以修改，如果不初始化会输出undefined，不会报错。</li><li>let是块级作用域，函数内部使用let定义后，对函数外部无影响。</li><li><strong>变量提升</strong>：无论var变量在函数何处，执行时都会被提升到函数最上部（不会出现error，但是可能会出现undefined）</li><li>let为块级作用域，使用{}划分，不能跨块访问</li></ul></li></ul><p>坑：</p><pre><code>console.log(a);//undefinedvar a = &quot;hey I am now hoisting&quot;;</code></pre><p>相当于</p><pre><code>var a;console.log(a);//undefineda = &quot;hey I am now hoisting&quot;</code></pre><p><strong>变量提升指的是变量声明的提升，不会提升变量的初始化和赋值。</strong></p><p><strong>ProtoType的使用</strong></p><pre><code> var dom = function(){};dom.Show = function(){    alert(&quot;Show Message&quot;);};dom.prototype.Display = function(){    alert(&quot;Property Message&quot;);};dom.Display(); //errordom.Show();  var d = new dom();d.Display();d.Show(); //error</code></pre><ol><li>不使用prototype属性定义的对象方法，是静态方法，只能直接用类名进行调用！另外，此静态方法中无法使用this变量来调用对象其他的属性！　　 </li><li>使用prototype属性定义的对象方法，是非静态方法，只有在实例化后才能使用！其方法内部可以this来引用对象自身中的其他属性！</li></ol><p>作用域</p><pre><code>var dom = function(){    var Name = &quot;Default&quot;;    this.Sex = &quot;Boy&quot;;    this.success = function(){        alert(&quot;Success&quot;);    };};alert(dom.Name);alert(dom.Sex);</code></pre><p>两个都显示Undefined,为什么呢？这是由于在Javascript中每个function都会形成一个作用域，而这些变量声明在函数中，所以就处于这个函数的作用域中，外部是无法访问的。要想访问变量，就必须new一个实例出来。</p><p><a href="https://www.cnblogs.com/yunfeifei/p/4019504.html" target="_blank" rel="external">推荐博客</a></p><h2 id="2018-07-20"><a href="#2018-07-20" class="headerlink" title="2018-07-20"></a>2018-07-20</h2><h3 id="JavaScript-2"><a href="#JavaScript-2" class="headerlink" title="JavaScript"></a>JavaScript</h3><p><strong>重中之重： 只有函数能创建作用域，其他的都不行</strong></p><p><strong>if()，for()等块语句，在块语句内部定义的变量会保留在它们已经存在的作用域内</strong></p><p><strong>ES6特性</strong><br><a href="https://www.jianshu.com/p/287e0bb867ae" target="_blank" rel="external">blog</a></p><p>object.call: 函数内部this指向了call或者apply指定的对象<br><a href="https://www.jianshu.com/p/00dc4ad9b83f" target="_blank" rel="external">call,bind,apply的使用</a></p><p>原型链及闭包理解<br><a href="http://www.cnblogs.com/wangfupeng1988/p/3979290.html" target="_blank" rel="external">blog</a></p><h2 id="2018-07-12-1"><a href="#2018-07-12-1" class="headerlink" title="2018-07-12"></a>2018-07-12</h2><h2 id="JavaScript-3"><a href="#JavaScript-3" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>this关键字指向：</p><ul><li>如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。平时为window对象</li><li>如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象。如果函数被赋值到了另一个变量中(var f = var.fn();fn();)，并没有作为obj的一个属性被调用，那么this的值就是window。</li><li>函数作为对象属性内部定义函数中的this指向window</li></ul><p><strong>作用域</strong></p><p>javascript除了全局作用域之外，只有函数可以创建的作用域。</p><p><img src="https://images0.cnblogs.com/blog/138012/201409/241708372951952.png" alt="作用域"></p><p>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。</p><p>JS闭包</p><p>闭包的作用</p><pre><code>        function f1(){        var n =1;        return function(){            alert(n)        }; } var result = f1(); result();//1</code></pre><p>  1：读取函数内部的变量</p><p>就如上面闭包的例子，可以在函数外部读取函数内部的变量。</p><p>  2：将变量的值始终保存在内存中</p><p>一般来讲，当函数执行完毕之后，函数内部的局部活动对象就会被销毁，内存中仅保存全局作用域，即js的内存回收机制。如果这个函数内部又嵌套了另一个函数,而这个函数是有可能在外部被调用到的.并且这个内部函数又使用了外部函数的某些变量的话.这种内存回收机制就会出现问题。如果在外部函数返回后,又直接调用了内部函数,那么内部函数就无法读取到他所需要的外部函数中变量的值了.所以js解释器在遇到函数定义的时候,会自动把函数和他可能使用的变量(包括本地变量和父级和祖先级函数的变量(自由变量))一起保存起来.也就是构建一个闭包,这些变量将不会被内存回收器所回收,只有当内部的函数不可能被调用以后(例如被删除了,或者没有了指针),才会销毁这个闭包,而没有任何一个闭包引用的变量才会被下一次内存回收启动时所回收。</p><p>坑：</p><pre><code>function createFunction(){    var result = new Array();    for( var i = 0; i &lt;10; i++){        result[i] = function(){            return i;        };    }    return result;}var aa = createFunction();alert(aa[0]());//10alert(aa[1]());//10</code></pre><p>在这个函数中，我们直接将闭包赋值给数组。这个函数会返回一个函数数组。表面上来看，似乎每个函数都应该返回自己的索引，即位置0的函数返回0，位置1的函数返回1一次类推。但实际上，如同上面例子，每个函数都返回了10。<strong>因为每个函数的作用域链中都保存createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()函数返回后，变量i的值死10，此时每个函数都引用着保存变量i的同一个变量对象。所以在每个函数内部i的值都是10。</strong></p><p>所以，我们可以通过如下例子，创建一个自执行函数（匿名函数）强制让闭包的行为符合预期。</p><pre><code>function createFunction1(){     var result = new Array();     for( var i = 0; i &lt;10; i++){         result[i] = function(num){             return function(){                 return num;             };         }(i);     }     return result; } var bb = createFunction1(); alert(bb[0]());//0 alert(bb[1]());//1</code></pre><p>从createFunctions1()这个函数的执行结果来看，每个函数都返回各自不同的索引值了，是什么原因呢？<br>在createFunctions1()这个函数中，我们没有直接将闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋值给数组。<strong>对于立即执行的匿名函数来说，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放。</strong>所以这里的匿名函数有一个参数num，也就是最终的函数要返回的值。在调用每个匿名函数时，我们传入了变量i。由于函数是按值传递的，所以会将变量i的当前值赋值给参数num，而这个匿名函数内部，又创建并返回了一个返回num的闭包。这样一来，result数组中的每个函数都有自己num的一个副本，因此就可以返回各自不同的数值了。</p><p>作用域链取值：</p><p><img src="https://images0.cnblogs.com/blog/138012/201409/251447377485132.png" alt="作用域链取值"></p><p><strong>要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”</strong></p><p>作用域链查找过程：</p><p>第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续；</p><p>第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；</p><p>第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；</p><p>第四步，跳转到第一步。</p><p><img src="https://images0.cnblogs.com/blog/138012/201409/251448515607115.png" alt=""></p><ul><li>箭头函数特性:箭头函数的this其实就是在定义的时候就确定好的，以后不管怎么调用这个箭头函数，箭头函数的this始终为定义时的this </li></ul><h2 id="2018-07-24"><a href="#2018-07-24" class="headerlink" title="2018-07-24"></a>2018-07-24</h2><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><p>线程状态</p><ul><li>新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();</li><li>就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，<strong>并不是说执行了t.start()此线程立即就会执行；</strong></li><li>运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</li><li><p>阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p><ul><li>等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</li><li>同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</li><li>其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li></ul></li><li><p>死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p></li></ul><p>sleep和wait的区别</p><ul><li>每个对象都有一个锁来控制同步访问，Synchronized关键字可以和对象的锁交互，来实现同步方法或同步块。执行sleep()方法后正在执行的线程主动让出CPU（然后CPU就可以去执行其他任务），在sleep指定时间后CPU再回到该线程继续往下执行(<strong>注意：sleep方法只让出了CPU，而并不会释放同步资源锁！！！</strong>)；wait()方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，<strong>只有调用了notify()方法，之前调用wait()的线程才会解除wait状态</strong>，可以去参与竞争同步资源锁，进而得到执行。（注意：notify的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说notify只是让之前调用wait的线程有权利重新参与线程的调度）；</li><li>sleep()方法可以在任何地方使用；wait()方法则只能在同步方法或同步块中使用；</li><li>sleep()是线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait()是Object的方法，调用会放弃对象锁，进入等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才会进入锁池，再次获得对象锁才会进入运行状态；</li></ul><p>线程安全</p><ul><li>Vector  HashTable  StringBuffer  statck enumeration是线程安全的.</li><li>ArrayList、 LinkedList、HashMap、StringBuilder 是非线程安全的。</li></ul><p>死锁</p><p> 产生死锁的原因主要是：</p><p>o   1） 因为系统资源不足。</p><p>o   2） 进程运行推进的顺序不合适。</p><p>o   3） 资源分配不当等。    </p><p>·     导致死锁的4个必要条件：</p><p>o   1、互斥条件。一次只有一个进程可以使用一个资源。其他进程不能访问已分配给其他进程的资源。</p><p>o   2、请求保持条件。当一个进程等待其他进程时，继续占有已经分配的资源。</p><p>o   3、不可剥夺条件。不能强行抢占进程已占有的资源。</p><p>o   4、循环等待条件。存在一个封闭的进程链，使得每个进程至少占有此链中下一个进程所需要的一个资源。</p><p><strong>synchronized</strong></p><p>当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。</p><p>o   一、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</p><p>o   二、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。</p><p>o   三、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。</p><p>o    四、第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。</p><p>HashMap</p><p>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Factor(负载因子)则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p><p>当key出现hash冲突的时候,链表中的第一个元素都是后面最新添加进来的那个,之前的则被next变量引用着。虽然这里是插入的动作,但是由于使用了链表,所以无需像数组的插入那样,进行数组拷贝。</p><p>ArrayList 和 LinkList</p><p>ArrayList与linkedList在性能上各有优缺点，都有各自的地方，</p><p>1.对ArrayList和LinkedList而言，在列表中末尾添加一个元素所花的开销是固定的</p><p>2.在ArrayList中间插入一个元素或删除一个元素意味着整个列表中剩余的元素都会移动，而LinkedList的中间插入或删除一个元素的开销是固定的</p><p>3.LinkedList不支持高效的随机访问</p><p> 可以这样说：当操作是在一列数据后面添加数据而不是在前面或中间，并且是随机访问其中元素时，使用arrayList会提供比较好的性能；当你操作是在一列数据的前面或中间添加或删除数据，并不是按照顺序访问其中的元素，就应该使用LinkedList了</p><p>线程 join</p><p>主线程(我在“一”里已经命名过了)等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。(Waits for this thread to die.)</p><p>乐观锁</p><p> 总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现。</p><p>悲观锁</p><p> 总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。</p><p>Synchronized与ReentrantLock的区别</p><p>对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成。</p><h2 id="2018-07-25"><a href="#2018-07-25" class="headerlink" title="2018-07-25"></a>2018-07-25</h2><h3 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h3><p>美团Java2018面试模拟题</p><ul><li><p>try{}语句块内不论有错误还是有return都会执行finally语句块，但下面的语句块不会再执行</p></li><li><p>RuntimeException 使用try{}，catc{}捕获不是必须的</p></li><li><p>sleep()方法并不会让出cpu</p></li><li><p>如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承</p></li><li>finally在异常处理时提供 finally 块来执行任何清除操作</li><li>Java使用 finalize() 方法在垃圾收集器象从内存中清除出去之前做必要的清理工作</li><li>static{}静态代码块首先执行，即，静态代码块-&gt;非静态代码块-&gt;构造器</li><li>Object类中没有copy方法</li><li>接口只能用public修饰，并且是抽象的；其中只能是抽象方法</li><li>子类不能继承父类构造方法，一个子类只能继承一个父类</li><li>构造方法是一种特殊的方法，它是一个与类同名且没有返回值类型的方法。</li><li>int 和Integer在进行比较的时候，Integer会进行拆箱，转为int值与int进行比较。整Integer字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象</li><li>Integer i01 = 59，java在编译的时候,被翻译成-&gt; Integer i01 = Integer.valueOf(59);</li><li>初始化时int类的变量初始为0.而Integer的变量则初始化为null.</li><li>自动装箱:Integer字面量的值在-128到127之间, Integer a = 127;相当于Integer a = new Integer(127)</li><li>方法中的<strong>局部变量</strong>，存放在栈区,类中的<strong>成员变量</strong>，存放在堆区</li><li>JAVA语言不允许程序员直接控制内存空间的使用。内存空间的分配和回收都是由JRE负责在后台自动进行的，尤其是无用内存空间的回收操作 (garbagecollection,也称垃圾回收)，只能由运行环境提供的一个超级线程进行监测和控制。</li></ul><h2 id="2018-07-25-1"><a href="#2018-07-25-1" class="headerlink" title="2018-07-25"></a>2018-07-25</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>redis相比memcached有哪些优势？ 　　</p><p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 </p><p>(2) redis的速度比memcached快很多</p><p>(3) redis可以持久化其数据</p><p>Memcache与Redis的区别都有哪些？<br>1)、存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，这样能保证数据的持久性。 </p><p>2)、数据支持类型 Memcache对数据类型支持相对简单。 Redis有复杂的数据类型。 </p><p>3)、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 </p><p>为什么redis需要把所有数据放到内存中?　</p><p>　　　Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。</p><p>　　　如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p><p><strong>和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。</strong></p><p>redis支持主从的模式。原则：Master会将数据同步到slave，而slave不会将数据同步到master。Slave启动时会连接master来同步数据。</p><p>这是一个典型的分布式读写分离模型。我们可以利用master来插入数据，slave提供检索服务。这样可以有效减少单个机器的并发访问数量</p><p> Redis 常见的性能问题都有哪些？如何解决？</p><p>1).Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。</p><p>2).Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</p><p>3).Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</p><p>4). Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</p><h3 id="SQL-1"><a href="#SQL-1" class="headerlink" title="SQL"></a>SQL</h3><p>SQL的join</p><pre><code>select column_name(s)from table 1INNER JOIN table 2ONtable 1.column_name=table 2.column_name</code></pre><p><img src="https://images2017.cnblogs.com/blog/1074709/201712/1074709-20171229165319538-1026266241.png" alt="innerjoin"></p><p>INNER JOIN产生的结果集中，是1和2的交集。</p><p><img src="https://images2017.cnblogs.com/blog/1074709/201712/1074709-20171229170434726-2010021622.png" alt=""></p><p>LEFT JOIN产生表1的完全集，而2表中匹配的则有值，没有匹配的则以null值取代。</p><p><img src="https://images2017.cnblogs.com/blog/1074709/201712/1074709-20171229171503867-2027149651.png" alt=""></p><p>RIGHT JOIN产生表2的完全集，而1表中匹配的则有值，没有匹配的则以null值取代。</p><p><img src="https://images2017.cnblogs.com/blog/1074709/201712/1074709-20171229172802179-389908324.png" alt=""></p><p>FULL OUTER JOIN产生1和2的并集。但是需要注意的是，对于没有匹配的记录，则会以null做为值。</p><p><strong>关键字: on</strong></p><p>数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。</p><p>在使用left jion时，on和where条件的区别如下：</p><p>1、 on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。</p><p>2、where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</p><p><strong>SQL优化</strong></p><ul><li>选取最适用的字段属性，尽量把字段设置为NOTNULL</li><li>使用连接（JOIN）来代替子查询(Sub-Queries)，连接（JOIN）..之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</li><li>使用联合(UNION)来代替手动创建的临时表</li><li>使用索引，一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况，在建有索引的字段上尽量不要使用函数进行操作。</li></ul><h3 id="JavaScript-4"><a href="#JavaScript-4" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>跨域方式</p><ul><li>response.setHeader(“Access-Control-Allow-Origin”, “*”);</li><li>使用标签进行跨域</li><li>jsonp方式不支持POST方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。</li><li>后端接口返回一个带有参数的方法名，其中函数的参数为返回信息，函数名为前端的回调函数名</li><li>jquery如果有success函数则默认success()作为回调函数。</li></ul><p><a href="https://www.cnblogs.com/mehjb/p/6125892.html" target="_blank" rel="external">HTML面试坑</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;知识点总结-不定时更新&quot;&gt;&lt;a href=&quot;#知识点总结-不定时更新&quot; class=&quot;headerlink&quot; title=&quot;知识点总结(不定时更新)&quot;&gt;&lt;/a&gt;知识点总结(不定时更新)&lt;/h1&gt;&lt;h2 id=&quot;2018-07-12&quot;&gt;&lt;a href=&quot;#2018-
      
    
    </summary>
    
      <category term="技术" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux备注</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2018/04/12/Linux%E5%A4%87%E6%B3%A8/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2018/04/12/Linux备注/</id>
    <published>2018-04-11T16:11:26.000Z</published>
    <updated>2018-04-11T22:24:24.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux备注"><a href="#Linux备注" class="headerlink" title="Linux备注"></a>Linux备注</h1><p><strong>Linux一些知识和技巧的备忘</strong></p><h2 id="2018-04-12"><a href="#2018-04-12" class="headerlink" title="2018-04-12"></a>2018-04-12</h2><h3 id="Linxu-环境变量文件"><a href="#Linxu-环境变量文件" class="headerlink" title="Linxu 环境变量文件"></a>Linxu 环境变量文件</h3><p>好久不见，最近出了一些事情导致没有心情更新博客。最近做毕业设计，刚好可以用Centos再回顾一下Linux的知识。</p><p>首先，关于.bashrc和.bash_profile。区分两者之间的区别，首先要搞清楚login shell和no-login shell之间的区别。</p><p>login shell: 当你通过终端输入用户名和密码，然后进入到terminal，这时候进入的shell环境就叫做是login shell，例如，通过ssh远程进入到主机。</p><p>no-login shell: 顾名思义就是不需要输入用户名密码而进入的shell环境，例如你已经登陆了你的桌面电脑，这时候在应用管理器中找到termianl图标，然后双击打开终端，也就是通过像gnome,KDE这种桌面环境而进入的终端，这时候你进入的shell环境就是所谓的no-login shell环境。简而言之，就是把你想通过login shell运行的shell命令放入到.bash_profile中，把想通过no-login shell运行的shell命令放入到.bashrc文件中。</p><p>Linux系统默认使用的shell为bash，在shell启动的时候会读取根据情况读取.bash_profile和.bashrc文件。准确的说，当shell是交互式登录shell时，读取.bash_profile文件，如在系统启动、远程登录或使用su -切换用户时；当shell是交互式登录和非登录shell时都会读取.bashrc文件，如：在图形界面中打开新终端或使用su切换用户时，均属于非登录shell的情况。简单的说，.bash_profile只在会话开始时被读取一次，而.bashrc则每次打开新的终端时，都会被读取。所以一些常用的<strong>alias</strong>还是应当放在<strong>.bashrc</strong>中。</p><h3 id="Shell-声明"><a href="#Shell-声明" class="headerlink" title="Shell 声明"></a>Shell 声明</h3><p>“#!/bin/sh”是对shell的声明，说明你所用的是那种类型的shell及其路径所在。</p><p>如果没有声明，则脚本将在默认的shell中执行，默认shell是由用户所在的系统定义为执行shell脚本的shell。</p><p>比如：如果脚本被编写为在Korn Linux中运行，而默认运行shell脚本的为C shell csh，则上述脚本在执行过程中很可能失败。</p><p> #!/bin/sh 是指此脚本使用/bin/sh来解释执行，#!是特殊的表示符，其后面根的是此解释此脚本的shell的路径。</p><p>其实第一句的#!是对脚本的解释器程序路径，脚本的内容是由解释器解释的，我们可以用各种各样的解释器来写对应的脚本。</p><p>比如说/bin/csh脚本，/bin/perl脚本，/bin/awk脚本，/bin/sed脚本，甚至/bin/echo等等。<br>所以建议大家就把”#!/bin/sh”当成C 语言的main函数一样，写shell必须有，以使shell程序更严密。</p><h3 id="source-sh-区别"><a href="#source-sh-区别" class="headerlink" title="./ source sh 区别"></a>./ source sh 区别</h3><p><strong>source命令用法：</strong></p><p>source FileName</p><p>作用:在当前bash环境下读取并执行FileName中的命令。该filename文件可以无”执行权限”</p><p>注：该命令通常用命令“.”来替代。</p><p>如：source .bash_profile</p><p>. .bash_profile两者等效。</p><p>source(或点)命令通常用于重新执行刚修改的初始化文档。</p><p>source命令(从 C Shell 而来)是bash shell的内置命令。</p><p>点命令，就是个点符号，(从Bourne Shell而来)。</p><p>source的程序主体是bash，脚本中的$0变量的值是bash，而且由于作用于当前bash环境，脚本中set的变量将直接起效</p><p><strong>sh, bash的命令用法：</strong></p><p>sh/bash FileName</p><p>作用:打开一个子shell来读取并执行FileName中命令。该filename文件可以无”执行权限”</p><p>注：运行一个shell脚本时会启动另一个命令解释器.</p><p>每个shell脚本有效地运行在父shell(parent shell)的一个子进程里.<br>这个父shell是指在一个控制终端或在一个xterm窗口中给你命令指示符的进程.<br>shell脚本也可以启动他自已的子进程.</p><p>这些子shell(即子进程)使脚本并行地，有效率地地同时运行脚本内的多个子任务.</p><p>在ubuntu中sh只是bash的一个链接。</p><p>由于是在子shell中执行，脚本设置的变量不会影响当前shell。</p><p><strong>./的命令用法：</strong></p><p>./FileName</p><p>作用:打开一个子shell来读取并执行FileName中命令。该filename文件需要”执行权限”</p><p>注：运行一个shell脚本时会启动另一个命令解释器.</p><p>每个shell脚本有效地运行在父shell(parent shell)的一个子进程里.</p><p>这个父shell是指在一个控制终端或在一个xterm窗口中给你命令指示符的进程.</p><p>shell脚本也可以启动他自已的子进程.</p><p>这些子shell(即子进程)使脚本并行地，有效率地地同时运行脚本内的多个子任务.</p><p>由于是在子shell中执行，脚本设置的变量不会影响当前shell。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux备注&quot;&gt;&lt;a href=&quot;#Linux备注&quot; class=&quot;headerlink&quot; title=&quot;Linux备注&quot;&gt;&lt;/a&gt;Linux备注&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Linux一些知识和技巧的备忘&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;2018-
      
    
    </summary>
    
      <category term="技术" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zx19951110.github.io/ZX.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>React-Native笔记</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2018/01/08/React-Native%E7%AC%94%E8%AE%B0/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2018/01/08/React-Native笔记/</id>
    <published>2018-01-08T14:46:02.000Z</published>
    <updated>2018-01-08T22:10:53.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Native-折腾笔记"><a href="#React-Native-折腾笔记" class="headerlink" title="React-Native 折腾笔记"></a>React-Native 折腾笔记</h1><p>老头子教授真的是默认我们什么都会，上次NavAPP用Vue和Yii重构前后端后还不够，第二个作业要让我们用安卓重构。。。没办法，不是很想花时间去学习安卓，所以就用React-Native来做一个安卓应用顺便学习一下。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>关于安装我不细说了，就是npm那一套，然后注意要装java的JRE和Android的SDK，安卓SDK可以通过Android Studio来安装。<br>调试的话使用命令react-native run-android，注意此时应启动安卓模拟器。</p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ul><li>2018-01-08 <ul><li>使用<strong>ListView</strong>时，渲染数据对象应是数组，如果需要渲染返回的JSON对象，应该用<strong>response[‘data’]</strong>来作为数组而不是<strong>response.data</strong></li><li>在<strong>ListView</strong>中的item使用点击事件，不要直接使用<strong>onPress={function()}</strong>,应该使用<strong>onPress={() =&gt; function())}</strong>，否则会渲染N次点击事件，原因不明。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React-Native-折腾笔记&quot;&gt;&lt;a href=&quot;#React-Native-折腾笔记&quot; class=&quot;headerlink&quot; title=&quot;React-Native 折腾笔记&quot;&gt;&lt;/a&gt;React-Native 折腾笔记&lt;/h1&gt;&lt;p&gt;老头子教授真的是默认
      
    
    </summary>
    
      <category term="技术" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://zx19951110.github.io/ZX.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>centos 安装 phpMyadmin</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2017/11/13/centos-%E5%AE%89%E8%A3%85-phpMyadmin/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2017/11/13/centos-安装-phpMyadmin/</id>
    <published>2017-11-12T16:13:58.000Z</published>
    <updated>2017-11-12T23:54:33.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Centos-安装-phpMyAdmin"><a href="#Centos-安装-phpMyAdmin" class="headerlink" title="Centos 安装 phpMyAdmin"></a>Centos 安装 phpMyAdmin</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>啊，教授好好的BPMN图不画，让我们去设计数据库，虽然在虚拟机上面有上次装的MariaDB（mysql），但是缺少了一个图形化界面，给人家七十岁老教授看也不太好。想起以前在百度使用的phpMyAdmin，打算折腾下。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>还不算复杂，首先我们切换到超级管理员</p><pre><code>$ su</code></pre><p>然后使用yum安装phpmyadmin</p><pre><code>$ yum install phpmyadmin</code></pre><p>比较有趣的是，虚拟机因为已经安装了Nginx,没有必要再安装个服务器了，但是执行上面的命令后yum会自动下载个Apache，并且phpmyadmin的<strong>服务器配置文件</strong>刚好就在/etc/httpd/conf.d/下面，这时候我们去访问虚拟机ip/phpmyadmin的话，我们会看到不讨人喜欢的403，这很明显是被服务器拒绝了，所以需要做一下修改：</p><pre><code>&lt;RequireAny&gt; //修改这个Dom节点# Require ip 127.0.0.1 //这里需要注释掉# Require ip : : 1 //这里也需要注释掉Require all granted //添加这一行&lt;/RequireAny&gt;</code></pre><p>ok我们再次访问，应该就会有欢迎界面了，如果不明白请<a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-phpmyadmin-with-apache-on-a-centos-7-server" target="_blank" rel="external">参考</a></p><p><img src="https://assets.digitalocean.com/articles/phpmyadmin_lamp_centos7/login.png" alt="欢迎"></p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><h3 id="mysql用户密码设置"><a href="#mysql用户密码设置" class="headerlink" title="mysql用户密码设置"></a>mysql用户密码设置</h3><p>是这样的，我安装的过程一切顺利直到上面那步，无法登录mysql服务器，于是我觉得可能是mysql的用户名密码没有设置，<strong>但是</strong>，我愚蠢的使用了下面的命令</p><pre><code>update from user set Password=&apos;123456&apos; where user=&apos;root&apos;;(错误！)</code></pre><p>因为mysql的用户表中的password字段是储存经过Password函数加密的，所以这样反而弄巧成拙，正确的方式应该是：</p><pre><code>update from user set Password=Passoword(&apos;123456&apos;) where user=&apos;root&apos;;(正确！)</code></pre><p>当然如果你改错了，再次登录mysql是没有办法修改mysql的主库的，所以需要采用mysql安全模式<br>首先停止mysql</p><pre><code>systemctl stop mariadb </code></pre><p>然后启动mysqld安全模式</p><pre><code>mysqld --skip-grant-tables &amp;</code></pre><p>成功启动mysql后修改密码，然后记得kill掉mysqld进程并重新启动mysql</p><pre><code>pa aux|grep mysqldkill -9 #idsystemctl start mariadb</code></pre><p>然后正常登录</p><pre><code>mysql -uroot -h127.0.0.1 -P3306</code></pre><p>输入密码，ok搞定。顺便一提mysql的配置文件在/etc/my.cnf.</p><h3 id="phpMyAdmin配置文件"><a href="#phpMyAdmin配置文件" class="headerlink" title="phpMyAdmin配置文件"></a>phpMyAdmin配置文件</h3><p>因为以普通用户登录不能修改配置文件，所以我获取管理员权限给配置文件777权限，给我坑惨了，phpmyadmin必须在755权限下才可以运行。<br>解决办法：</p><pre><code>chmod -cR 755 /etc/phpMyAdmin/config.inc.php</code></pre><p>然后以<strong>管理员身份修改登录mysql的用户密码端口host</strong>等。。这里也有坑：输入用户名密码无法连接到数据库。网上很多人说修改成这样。</p><pre><code>$cfg[&apos;Servers&apos;][$i][&apos;host&apos;] = &apos;127.0.0.1&apos;</code></pre><p>实际上不用改，保持这样</p><pre><code>$cfg[&apos;Servers&apos;][$i][&apos;host&apos;] = &apos;localhost&apos;</code></pre><p>后来想一想可能是因为mysql的主库user表记录的host问题吧，然后就可以美滋滋登录进去啦<br><img src="https://assets.digitalocean.com/articles/phpmyadmin_lamp_centos7/main_page.png" alt="界面"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Centos-安装-phpMyAdmin&quot;&gt;&lt;a href=&quot;#Centos-安装-phpMyAdmin&quot; class=&quot;headerlink&quot; title=&quot;Centos 安装 phpMyAdmin&quot;&gt;&lt;/a&gt;Centos 安装 phpMyAdmin&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="后端" scheme="https://zx19951110.github.io/ZX.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Centos 安装 Python3</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2017/11/11/Centos-%E5%AE%89%E8%A3%85-Python3/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2017/11/11/Centos-安装-Python3/</id>
    <published>2017-11-11T04:26:46.000Z</published>
    <updated>2017-11-11T11:48:52.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Centos-安装-Python3"><a href="#Centos-安装-Python3" class="headerlink" title="Centos 安装 Python3"></a>Centos 安装 Python3</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>越来越发现Python非常有用，同时也希望自己在读研过程中在百度学到的东西不会忘掉，所以打算继续深入学习Python3。但是虚拟机上面的Python是2.7，而且yum镜像站中Python默认也是2，但是Python3越来越成为主流，所以有必要这么折腾一下。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>如果是以最小镜像安装的Linux的话，是不会有wget等有用的模块的，所以我们需要：</p><pre><code>yum -y install wget</code></pre><p>安装好wget后，再：</p><pre><code>yum groupinstall &apos;Development Tools&apos;yum install zlib-devel bzip2-devel openssl-devel ncurese-devel</code></pre><h3 id="编译-amp-安装"><a href="#编译-amp-安装" class="headerlink" title="编译&amp;安装"></a>编译&amp;安装</h3><p>ok前期工作搞定，然后去Python镜像站看一下Python的版本，再wget下来：</p><pre><code>wget https://www.python.org/ftp/python/3.5.1/Python-3.5.1.tar.xz</code></pre><p>下载后解压并且编译安装（sudo）：</p><pre><code>tar Jxvf Python-3.5.1.tar.xzcd Python-3.5.1./configure --prefix=/usr/local/python3make &amp;&amp; make install</code></pre><p>这时如果成功的话python3.5.1就安装到了prefix指定的目录下面，如果添加系统命令的话，需要将python3文件软连接到/usr/bin下面</p><pre><code>$ sudo ln -s /usr/local/python3/bin/python3 /usr/bin/python3</code></pre><p>我们在系统中以python3命令调用python3就可以啦，顺便一提yum是使用python2版本，如果改变全局python的话，可能会导致yum等使用python2的软件无法工作。</p><h3 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h3><p>一般来讲，安装python3会自动安装pip，将pip添加到系统命令中和安装python3一样，创建软连接：</p><pre><code>$ sudo ln -s /usr/local/python3/bin/pip3 /usr/bin/pip</code></pre><p>然后搞定，如果没有默认安装pip的话可以参考<a href="https://ehlxr.me/2017/01/07/CentOS-7-%E5%AE%89%E8%A3%85-Python3%E3%80%81pip3/" target="_blank" rel="external">这篇文章</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Centos-安装-Python3&quot;&gt;&lt;a href=&quot;#Centos-安装-Python3&quot; class=&quot;headerlink&quot; title=&quot;Centos 安装 Python3&quot;&gt;&lt;/a&gt;Centos 安装 Python3&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zx19951110.github.io/ZX.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>折腾Centos7系统</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2017/10/29/%E6%8A%98%E8%85%BECentos7%E7%B3%BB%E7%BB%9F/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2017/10/29/折腾Centos7系统/</id>
    <published>2017-10-29T04:36:14.000Z</published>
    <updated>2017-10-29T05:09:14.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux这么好玩，为什么不折腾一下呢"><a href="#Linux这么好玩，为什么不折腾一下呢" class="headerlink" title="Linux这么好玩，为什么不折腾一下呢"></a>Linux这么好玩，为什么不折腾一下呢</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了留学离职了这么久，最后还不是要回去当程序员，所以还是要学习一下Linux的基本操作呀。穷人买不起苹果没办法玩terminal，用git的bush还不是很爽，双系统还怕崩掉，只能用虚拟机装个centos解解馋喽。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>很简单的，去centos下载iso镜像，然后使用VM WorkStation去加载镜像，根据提示一步一步来，因为我打算作为服务器搞事情，所以就把内存和cpu分配的高了一点。需要注意的有一些：</p><h3 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h3><p>虚拟机联网需要使用桥接模式，这个在设置中有提到，记得选中，然后就是更坑爹的系统设置，转到/etc/sysconfig/network-scripts/</p><p><img src="https://imgsa.baidu.com/exp/w=500/sign=289bc0820bf3d7ca0cf63f76c21ebe3c/b17eca8065380cd7219a2551a644ad3458828182.jpg" alt="列表"></p><p>没错ifcfg后面一串数字的就是需要修改的文件，记得使用sudo chmod 777 更改这个文件的权限，然后用vi编辑这个文件，将最后一行的ONBOOT=no改为ONBOOT=yes，然后保存退出。</p><p><img src="https://imgsa.baidu.com/exp/w=500/sign=f14107038b5494ee87220f191df4e0e1/d0c8a786c9177f3e65967ab177cf3bc79e3d56ef.jpg" alt="更改"></p><p>然后您就可以愉悦的使用centos的强大的yum了</p><h3 id="mysql的安装问题"><a href="#mysql的安装问题" class="headerlink" title="mysql的安装问题"></a>mysql的安装问题</h3><p>mysql这么实用，为什么不装个mysql呢，在Linux中，mysql是一个client，而mysqld是一个服务，所以需要安装服务和客户端。但是！！！但是！！！CentOS 7 版本将MySQL数据库软件从默认的程序列表中移除，用mariadb代替了，妈的坑死我了。<br>所以需要使用MariaDB：</p><p>MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。<br>所以安装Mysql的全部步骤如下：</p><pre><code>#yum install mysql#yum yum install mariadb-server mariadb #yum install mysql-devel</code></pre><p>下面是一些mariadb的常用命令：</p><pre><code>systemctl start mariadb  #启动MariaDBsystemctl stop mariadb  #停止MariaDBsystemctl restart mariadb  #重启MariaDB  systemctl enable mariadb  #设置开机启动</code></pre><p>之后就可以正常使用Mysql了，然后把在所有数据库的所有表的所有权限赋值给位于所有IP地址的root用户。</p><pre><code>mysql&gt; grant all privileges on *.* to root@&apos;%&apos;identified by &apos;password&apos;;</code></pre><p>如果是新用户而不是root，则要先新建用户</p><pre><code>mysql&gt;create user &apos;username&apos;@&apos;%&apos; identified by &apos;password&apos;; </code></pre><p>感谢<a href="https://www.cnblogs.com/starof/p/4680083.html" target="_blank" rel="external">Blog</a></p><h3 id="Nginx安装问题"><a href="#Nginx安装问题" class="headerlink" title="Nginx安装问题"></a>Nginx安装问题</h3><p>如果您直接yum install nginx，那是不行的，貌似yum的镜像站没有nginx，所以你需要安装CentOS 7 EPEL repository</p><pre><code>sudo yum install epel-release</code></pre><p>然后就可以</p><pre><code>yum install nginx</code></pre><p>nginx的启动命令是</p><pre><code>sudo systemctl start nginx</code></pre><p>ok，然后通过curl命令访问127.0.0.1，可以看到欢迎界面的html的返回。<br>然后使用ifconfig命令，就可以看到虚拟机的地址了，但是，使用windows系统并不能访问到，一般来讲是因为防火墙问题，所以需要做如下修改：</p><pre><code>iptables -Fiptables -P INPUT ACCEPT（设置默认允许规则）</code></pre><p>反正我到了这步骤就可以访问到了虚拟机，如果还是不行的话，请参考<a href="http://www.easytd.com/gongjufangfa/d_14121820330.html" target="_blank" rel="external">博客</a></p><h2 id="附yum命令"><a href="#附yum命令" class="headerlink" title="附yum命令"></a>附yum命令</h2><p>yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p><p>yum的命令形式一般是如下：</p><pre><code>yum [options] [command] [package ...]</code></pre><p>其中的[options]是可选的，选项包括-h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）等等。[command]为所要进行的操作，[package …]是操作的对象。</p><p>概括了部分常用的命令包括：</p><pre><code>自动搜索最快镜像插件：   yum install yum-fastestmirror安装yum图形窗口插件：    yum install yumex查看可能批量安装的列表： yum grouplist</code></pre><p>1 安装</p><pre><code>yum install 全部安装yum install package1 安装指定的安装包package1yum groupinsall group1 安装程序组group1</code></pre><p>2 更新和升级</p><pre><code>yum update 全部更新yum update package1 更新指定程序包package1yum check-update 检查可更新的程序yum upgrade package1 升级指定程序包package1yum groupupdate group1 升级程序组group1</code></pre><p>3 查找和显示</p><pre><code>yum info package1 显示安装包信息package1yum list 显示所有已经安装和可以安装的程序包yum list package1 显示指定程序包安装情况package1yum groupinfo group1 显示程序组group1信息yum search string 根据关键字string查找安装包</code></pre><p>4 删除程序</p><pre><code>yum remove &amp;#124; erase package1 删除程序包package1yum groupremove group1 删除程序组group1yum deplist package1 查看程序package1依赖情况</code></pre><p>5 清除缓存</p><pre><code>yum clean packages 清除缓存目录下的软件包yum clean headers 清除缓存目录下的 headersyum clean oldheaders 清除缓存目录下旧的 headersyum clean, yum clean all (= yum clean packages; yum clean oldheaders) 清除缓存目录下的软件包及旧的headers</code></pre><p>不常用的命令请参考<a href="http://www.cnblogs.com/chuncn/archive/2010/10/17/1853915.html" target="_blank" rel="external">这篇博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux这么好玩，为什么不折腾一下呢&quot;&gt;&lt;a href=&quot;#Linux这么好玩，为什么不折腾一下呢&quot; class=&quot;headerlink&quot; title=&quot;Linux这么好玩，为什么不折腾一下呢&quot;&gt;&lt;/a&gt;Linux这么好玩，为什么不折腾一下呢&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="技术" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zx19951110.github.io/ZX.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>意大利留学（二）</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2017/10/13/%E6%84%8F%E5%A4%A7%E5%88%A9%E7%95%99%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2017/10/13/意大利留学（二）/</id>
    <published>2017-10-13T15:36:04.000Z</published>
    <updated>2017-10-14T09:06:19.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="意大利-帕维亚大学留学"><a href="#意大利-帕维亚大学留学" class="headerlink" title="意大利-帕维亚大学留学"></a>意大利-帕维亚大学留学</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Ciao各位，截止到现在已经在意大利生活了快三个星期了，也已经对这个国家有了更深一层的了解，那就作为上次博客的一个补充。</p><h2 id="上课"><a href="#上课" class="headerlink" title="上课"></a>上课</h2><p>帕维亚大学分为两个校区，市中心看起来很有历史感的是老校区，伏特的母校，目前多为经济系等偏文科学科在此使用。而偏北的校区就是我们上课的工程系，现代化的校舍，让我想起了在新国大实训的那段时间。</p><p>我所在的帕维亚大学是欧洲第二古老的大学，自然排名也很靠前，据说是比你电高一个阶段。再加上国外的大学宽进严出的政策导致了学业上比中国更大的压力。帕维亚大学的王牌专业是医学系，所以医学系的学生压力是很大的。听学长说住在一个宿舍的印度学生因为压力过大自杀。而计算机系还好，相比之下压力小了很多。我们的教授是一个即将退休的奇怪小老头，叫Motta，稍微懂一些中国文化，脾气琢磨不定，对男生要更严格一些。据说他很富有，在米兰有一条街以他的名字命名。这个大肚子小老头上课喜欢手舞足蹈，面带微笑，但是讲的英语有一些很高级的词汇，跟起来还是有一些吃力的。不过回去翻译lecture和做作业，也是能理解个大概的。过段时间适应了应该会好很多。</p><h2 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h2><p>毕竟身处欧罗巴大陆，两年时间如果有机会肯定还是要到处走一走的。感觉这边每个国家的面积都不大，出国和出省一样，一两个小时的车程就可以到另一个国家。上周末我们去了科莫湖Lago di Como<br>,米兰北部，阿尔卑斯山下的冰川湖，湖水很蓝天气很好，附近的山顶可以远眺一片积雪的阿尔卑斯山，再往北就是瑞士。打算圣诞的假期，或者狂欢节趁着签证还有效尽量多出去走一走开阔一些眼界，毕竟这个机会这辈子可能不会再有第二次。威尼斯、圣诞老人村、极光、欧洲大陆极西点等等，如果有机会肯定是要去的。</p><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>日常交流依然很艰难，毕竟两个国家的人使用第三个国家的语言交流还是有一些难度。不过意大利人真的很热心，我们弄丢了信箱的钥匙没有看到邮局发来的avviso，楼上的老夫妻会主动过来提醒我们，我们弄丢钥匙老爷爷主动帮我们撬开锁。目前还没有遇到种族歧视等现象。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前也先总结这么多,更多的事还需要靠时间来体验,CiaoCiao~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;意大利-帕维亚大学留学&quot;&gt;&lt;a href=&quot;#意大利-帕维亚大学留学&quot; class=&quot;headerlink&quot; title=&quot;意大利-帕维亚大学留学&quot;&gt;&lt;/a&gt;意大利-帕维亚大学留学&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head
      
    
    </summary>
    
      <category term="杂谈" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="留学" scheme="https://zx19951110.github.io/ZX.github.io/tags/%E7%95%99%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>NPM使用技巧</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2017/10/06/NPM%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2017/10/06/NPM使用技巧/</id>
    <published>2017-10-06T08:44:14.000Z</published>
    <updated>2017-10-14T09:06:07.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NPM命令参数解析"><a href="#NPM命令参数解析" class="headerlink" title="NPM命令参数解析"></a>NPM命令参数解析</h1><p>最近在学Node，自然少不了对NPM这优秀的包管理软件的接触，这里总结一下NPM的使用命令和说明</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Nodejs作为一个模块化的语言，很多依赖都是由外部引用，在node_modules文件夹中。其中和node_modules文件夹平级的一个package.json保存了包的信息，当安装更新包的时候，npm会根据package.json的信息进行安装。</p><h2 id="Npm命令使用方法"><a href="#Npm命令使用方法" class="headerlink" title="Npm命令使用方法"></a>Npm命令使用方法</h2><p>一般来讲安装完Npm因为国外镜像站被墙了所以需要使用国内镜像站，一般来讲使用淘宝镜像</p><ul><li><p>临时使用</p><pre><code>npm --registry https://registry.npm.taobao.org install express</code></pre></li><li><p>持久使用</p><pre><code>npm config set registry https://registry.npm.taobao.org</code></pre><p>配置后可通过下面方式来验证是否成功 </p><pre><code>npm config get registry或 npm info express</code></pre></li></ul><ul><li>npm install 使用npm安装模块的命令，有很多参数<ul><li>-g 全局安装</li><li>-S, –save 安装包信息将加入到dependencies（生产阶段的依赖） 写进package.json</li><li>-D, –save-dev 安装包信息将加入到devDependencies（开发阶段的依赖），所以开发阶段一般使用它，这样安装的包的名称及版本号就会存在package.json的devDependencies这个里面，而–save会将包的名称及版本号放在dependencies里面。</li><li>-O, –save-optional 安装包信息将加入到optionalDependencies（可选阶段的依赖）</li><li>-E, –save-exact 精确安装指定模块版本</li></ul></li></ul><p>其他常用命令</p><pre><code>npm ls 查看安装的模块npm ls -g 查看全局安装模块npm uninstall卸载模块npm update更新模块npm outdated检查模块是否已经过时npm init在项目中引导创建一个package.json文件npm help 查看某条命令的详细帮助</code></pre><h4 id="引用博客"><a href="#引用博客" class="headerlink" title="引用博客"></a><a href="http://www.jb51.net/article/86253.htm" target="_blank" rel="external">引用博客</a></h4><h2 id="package-json信息"><a href="#package-json信息" class="headerlink" title="package.json信息"></a>package.json信息</h2><p>package.json中最重要的属性是name和version两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。</p><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><ul><li>name必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。</li><li>name不能以”_”或”.”开头</li><li>不能含有大写字母</li><li>name会成为url的一部分，不能含有url非法字符</li></ul><p>下面是官网文档的一些建议：</p><ul><li><p>不要使用和node核心模块一样的名称</p><p>  name中不要含有”js”和”node”。 It’s assumed that it’s js, since you’re writing a package.json file, and you can specify the engine using the “engines” field. (See below.)<br>  name属性会成为模块url、命令行中的一个参数或者一个文件夹名称，任何非url安全的字符在name中都不能使用，也不能以”_”或”.”开头<br>  name属性也许会被写在require()的参数中，所以最好取个简短而语义化的值。<br>  创建一个模块前可以先到后边的网址查查name是否已经被占用. <a href="https://www.npmjs.com/" target="_blank" rel="external">https://www.npmjs.com/</a><br>  name属性可以有一些前缀如 e.g. @myorg/mypackage.在npm-scope(7)的文档中可以看到详细说明</p></li></ul><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>version必须可以被npm依赖的一个node-semver模块解析。具体规则见下面的dependencies模块</p><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>一个描述，方便别人了解你的模块作用，搜索的时候也有用。</p><h3 id="keywords"><a href="#keywords" class="headerlink" title="keywords"></a>keywords</h3><p>一个字符串数组，方便别人搜索到本模块</p><h3 id="homepage"><a href="#homepage" class="headerlink" title="homepage"></a>homepage</h3><p>项目主页url</p><pre><code>注意: 这个项目主页url和url属性不同，如果你填写了url属性，npm注册工具会认为你把项目发布到其他地方了，获取模块的时候不会从npm官方仓库获取，而是会重定向到url属性配置的地址。（原文档中用了 spit(吐)这个单词，作者表示他不是在开玩笑:）</code></pre><h3 id="bugs"><a href="#bugs" class="headerlink" title="bugs"></a>bugs</h3><p>填写一个bug提交地址或者一个邮箱，被你的模块坑到的人可以通过这里吐槽，例如：</p><pre><code>{ &quot;url&quot; : &quot;https://github.com/owner/project/issues&quot;, &quot;email&quot; : &quot;project@hostname.com&quot;}</code></pre><p>url和email可以任意填或不填，如果只填一个，可以直接写成一个字符串而不是对象。如果填写了url，npm bugs命令会使用这个url。</p><h3 id="license"><a href="#license" class="headerlink" title="license"></a>license</h3><p>你应该为你的模块制定一个协议，让用户知道他们有何权限来使用你的模块，以及使用该模块有哪些限制。最简单的，例如你用BSD-3-Clause 或 MIT之类的协议，如下：</p><pre><code>{ &quot;license&quot; : &quot;BSD-3-Clause&quot; }</code></pre><p>你可以在<a href="https://spdx.org/licenses/这个地址查阅协议列表" target="_blank" rel="external">https://spdx.org/licenses/这个地址查阅协议列表</a> 。</p><h3 id="和用户相关的属性-author-contributors"><a href="#和用户相关的属性-author-contributors" class="headerlink" title="和用户相关的属性: author, contributors"></a>和用户相关的属性: author, contributors</h3><p>“author”是一个码农， “contributors”是一个码农数组。 “person”是一个有一些描述属性的对象，如下 like this:</p><pre><code>{ &quot;name&quot; : &quot;Barney Rubble&quot;, &quot;email&quot; : &quot;b@rubble.com&quot;, &quot;url&quot; : &quot;http://barnyrubble.tumblr.com/&quot;}</code></pre><p>也可以按如下格式缩写，npm会帮着转换:<br>“Barney Rubble b@rubble.com (<a href="http://barnyrubble.tumblr.com/" target="_blank" rel="external">http://barnyrubble.tumblr.com/</a>)”<br>email和url属性实际上都是可以省略的。描述用户信息的还有一个”maintainers”（维护者）属性。</p><h3 id="files"><a href="#files" class="headerlink" title="files"></a>files</h3><p>“files”属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了）<br>你也可以在模块根目录下创建一个”.npmignore”文件（windows下无法直接创建以”.”开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法”.gitignore”类似。</p><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>main属性指定了程序的主入口文件。意思是，如果你的模块被命名为foo，用户安装了这个模块并通过require(“foo”)来使用这个模块，那么require返回的内容就是main属性指定的文件中 module.exports指向的对象。<br>它应该指向模块根目录下的一个文件。对大对数模块而言，这个属性更多的是让模块有一个主入口文件，然而很多模块并不写这个属性。</p><h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的）<br>如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：</p><pre><code>{ &quot;bin&quot; : { &quot;myapp&quot; : &quot;./cli.js&quot; } }</code></pre><p>模块安装的时候，若是全局安装，则npm会为bin中配置的文件在bin目录下创建一个软连接（对于windows系统，默认会在C:\Users\username\AppData\Roaming\npm目录下），若是局部安装，则会在项目内的./node_modules/.bin/目录下创建一个软链接。<br>因此，按上面的例子，当你安装myapp的时候，npm就会为cli.js在/usr/local/bin/myapp路径创建一个软链接。<br>如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：</p><pre><code>{ &quot;name&quot;: &quot;my-program&quot;, &quot;version&quot;: &quot;1.2.5&quot;, &quot;bin&quot;: &quot;./path/to/program&quot; }</code></pre><p>作用和如下写法相同:</p><pre><code>{ &quot;name&quot;: &quot;my-program&quot;, &quot;version&quot;: &quot;1.2.5&quot;, &quot;bin&quot; : { &quot;my-program&quot; : &quot;./path/to/program&quot; } }</code></pre><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>制定一个或通过数组制定一些文件来让linux下的man命令查找文档地址。<br>如果只有一个文件被指定的话，安装后直接使用man+模块名称，而不管man指定的文件的实际名称。例如:</p><pre><code>{ &quot;name&quot; : &quot;foo&quot;, &quot;version&quot; : &quot;1.2.3&quot;, &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;, &quot;main&quot; : &quot;foo.js&quot;, &quot;man&quot; : &quot;./man/doc.1&quot;}</code></pre><p>通过man foo命令会得到 ./man/doc.1 文件的内容。<br>如果man文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：</p><pre><code>{ &quot;name&quot; : &quot;foo&quot;, &quot;version&quot; : &quot;1.2.3&quot;, &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;, &quot;main&quot; : &quot;foo.js&quot;, &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/bar.1&quot; ]}</code></pre><p>会创建一些文件来作为man foo和man foo-bar命令的结果。<br>man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。</p><pre><code>{ &quot;name&quot; : &quot;foo&quot;, &quot;version&quot; : &quot;1.2.3&quot;, &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;, &quot;main&quot; : &quot;foo.js&quot;, &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/foo.2&quot; ]}</code></pre><p>会创建 man foo 和 man 2 foo 两条命令。</p><h3 id="directories"><a href="#directories" class="headerlink" title="directories"></a>directories</h3><p>CommonJs通过directories来制定一些方法来描述模块的结构，看看npm的package.json文件<a href="https://registry.npmjs.org/npm/latest" target="_blank" rel="external">https://registry.npmjs.org/npm/latest</a> ，可以发现里边有这个字段的内容。</p><p>目前这个配置没有任何作用，将来可能会整出一些花样来。</p><ul><li><p>directories.lib</p><p>  告诉用户模块中lib目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。</p></li><li><p>directories.bin</p><p>  如果你在这里指定了bin目录，这个配置下面的文件会被加入到bin路径下，如果你已经在package.json中配置了bin目录，那么这里的配置将不起任何作用。</p></li><li><p>directories.man</p><p>  指定一个目录，目录里边都是man文件，这是一种配置man文件的语法糖。</p></li><li><p>directories.doc</p><p>  在这个目录里边放一些markdown文件，可能最终有一天它们会被友好的展现出来（应该是在npm的网站上）</p></li><li><p>directories.example</p><p>  放一些示例脚本，或许某一天会有用 - -！</p></li></ul><h3 id="repository"><a href="#repository" class="headerlink" title="repository"></a>repository</h3><p>指定一个代码存放地址，对想要为你的项目贡献代码的人有帮助。像这样：</p><pre><code>&quot;repository&quot; :{ &quot;type&quot; : &quot;git&quot;, &quot;url&quot; : &quot;https://github.com/npm/npm.git&quot;}&quot;repository&quot; :{ &quot;type&quot; : &quot;svn&quot;, &quot;url&quot; : &quot;https://v8.googlecode.com/svn/trunk/&quot;}若你的模块放在GitHub, GitHub gist, Bitbucket, or GitLab的仓库里，npm install的时候可以使用缩写标记来完成：&quot;repository&quot;: &quot;npm/npm&quot;&quot;repository&quot;: &quot;gist:11081aaa281&quot;&quot;repository&quot;: &quot;bitbucket:example/repo&quot;&quot;repository&quot;: &quot;gitlab:another/repo&quot;</code></pre><h3 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h3><p>scripts属性是一个对象，里边指定了项目的生命周期个各个环节需要执行的命令。key是生命周期中的事件，value是要执行的命令。<br>具体的内容有 install start stop 等，详见<a href="https://docs.npmjs.com/misc/scripts" target="_blank" rel="external">https://docs.npmjs.com/misc/scripts</a></p><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>用来设置一些项目不怎么变化的项目配置，例如port等。<br>用户用的时候可以使用如下用法：</p><p>http.createServer(…).listen(process.env.npm_package_config_port)<br>可以通过npm config set foo:port 80来修改config。详见<a href="https://docs.npmjs.com/misc/config" target="_blank" rel="external">https://docs.npmjs.com/misc/config</a></p><pre><code>{ &quot;name&quot; : &quot;foo&quot;, &quot;config&quot; : { &quot;port&quot; : &quot;8080&quot; } }</code></pre><h3 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h3><p>dependencies属性是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围，版本范围是一个字符，可以被一个或多个空格分割。<br>dependencies也可以被指定为一个git地址或者一个压缩包地址。<br>不要把测试工具或transpilers写到dependencies中。 下面是一些写法，详见<a href="https://docs.npmjs.com/misc/semver" target="_blank" rel="external">https://docs.npmjs.com/misc/semver</a></p><h3 id="version-精确匹配版本"><a href="#version-精确匹配版本" class="headerlink" title="version 精确匹配版本"></a>version 精确匹配版本</h3><ul><li>》version 必须大于某个版本</li><li>》=version 大于等于</li><li>&lt;version 小于</li><li>&lt;=versionversion 小于</li><li>~version “约等于”，具体规则详见semver文档</li><li>^version “兼容版本”具体规则详见semver文档</li><li>1.2.x 仅一点二点几的版本</li><li>http://… 见下面url作为denpendencies的说明</li><li>version1 - version2 相当于 &gt;=version1 &lt;=version2.</li><li>range1 || range2 范围1和范围2满足任意一个都行</li><li>git… 见下面git url作为denpendencies的说明</li><li>user/repo See 见下面GitHub仓库的说明</li><li>tag 发布的一个特殊的标签，见npm-tag的文档 <a href="https://docs.npmjs.com/getting-started/using-tags" target="_blank" rel="external">https://docs.npmjs.com/getting-started/using-tags</a></li><li>path/path/path 见下面本地模块的说明</li></ul><p>下面的写法都是可以的:</p><pre><code>{ &quot;dependencies&quot; :  { &quot;foo&quot; : &quot;1.0.0 - 2.9999.9999&quot;  , &quot;bar&quot; : &quot;&gt;=1.0.2 &lt;2.1.2&quot;  , &quot;baz&quot; : &quot;&gt;1.0.2 &lt;=2.3.4&quot;  , &quot;boo&quot; : &quot;2.0.1&quot;  , &quot;qux&quot; : &quot;&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0&quot;  , &quot;asd&quot; : &quot;http://asdf.com/asdf.tar.gz&quot;  , &quot;til&quot; : &quot;~1.2&quot;  , &quot;elf&quot; : &quot;~1.2.3&quot;  , &quot;two&quot; : &quot;2.x&quot;  , &quot;thr&quot; : &quot;3.3.x&quot;  , &quot;lat&quot; : &quot;latest&quot;  , &quot;dyl&quot; : &quot;file:../dyl&quot;  }}</code></pre><h3 id="URLs-as-Dependencies"><a href="#URLs-as-Dependencies" class="headerlink" title="URLs as Dependencies"></a>URLs as Dependencies</h3><p>在版本范围的地方可以写一个url指向一个压缩包，模块安装的时候会把这个压缩包下载下来安装到模块本地。</p><p>Git URLs as Dependencies</p><p>Git url可以像下面一样:</p><p>git://github.com/user/project.git#commit-ish<br>git+ssh://user@hostname:project.git#commit-ish<br>git+ssh://user@hostname/project.git#commit-ish<br>git+<a href="http://user@hostname/project/blah.git#commit-ish" target="_blank" rel="external">http://user@hostname/project/blah.git#commit-ish</a><br>git+<a href="https://user@hostname/project/blah.git#commit-ish" target="_blank" rel="external">https://user@hostname/project/blah.git#commit-ish</a><br>commit-ish 可以是任意标签，哈希值，或者可以检出的分支，默认是master分支。</p><h3 id="GitHub-URLs"><a href="#GitHub-URLs" class="headerlink" title="GitHub URLs"></a>GitHub URLs</h3><p>支持github的 username/modulename 的写法，#后边可以加后缀写明分支hash或标签：</p><pre><code>{  &quot;name&quot;: &quot;foo&quot;,  &quot;version&quot;: &quot;0.0.0&quot;,  &quot;dependencies&quot;: {    &quot;express&quot;: &quot;visionmedia/express&quot;,    &quot;mocha&quot;: &quot;visionmedia/mocha#4727d357ea&quot;  }}</code></pre><h3 id="Local-Paths"><a href="#Local-Paths" class="headerlink" title="Local Paths"></a>Local Paths</h3><p>npm2.0.0版本以上可以提供一个本地路径来安装一个本地的模块，通过npm install xxx –save 来安装，格式如下：</p><pre><code>../foo/bar~/foo/bar./foo/bar/foo/bar</code></pre><p>package.json 生成的相对路径如下:</p><pre><code>{  &quot;name&quot;: &quot;baz&quot;,  &quot;dependencies&quot;: {    &quot;bar&quot;: &quot;file:../foo/bar&quot;  }}</code></pre><p>这种属性在离线开发或者测试需要用npm install的情况，又不想自己搞一个npm server的时候有用，但是发布模块到公共仓库时不应该使用这种属性。</p><h3 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h3><p>如果有人想要下载并使用你的模块，也许他们并不希望或需要下载一些你在开发过程中使用的额外的测试或者文档框架。<br>在这种情况下，最好的方法是把这些依赖添加到devDependencies属性的对象中。<br>这些模块会在npm link或者npm install的时候被安装，也可以像其他npm配置一样被管理，详见npm的config文档。<br>对于一些跨平台的构建任务，例如把CoffeeScript编译成JavaScript，就可以通过在package.json的script属性里边配置prepublish脚本来完成这个任务，然后需要依赖的coffee-script模块就写在devDependencies属性种。<br>例如:</p><pre><code>{ &quot;name&quot;: &quot;ethopia-waza&quot;,  &quot;description&quot;: &quot;a delightfully fruity coffee varietal&quot;,  &quot;version&quot;: &quot;1.2.3&quot;,  &quot;devDependencies&quot;: {    &quot;coffee-script&quot;: &quot;~1.6.3&quot;  },  &quot;scripts&quot;: {    &quot;prepublish&quot;: &quot;coffee -o lib/ -c src/waza.coffee&quot;  },  &quot;main&quot;: &quot;lib/waza.js&quot;}</code></pre><p>prepublish脚本会在发布之前运行，因此用户在使用之前就不用再自己去完成编译的过程了。在开发模式下，运行npm install也会执行这个脚本（见npm script文档），因此可以很方便的调试。</p><h3 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a>peerDependencies</h3><p>有时候做一些插件开发，比如grunt等工具的插件，它们往往是在grunt的某个版本的基础上开发的，而在他们的代码中并不会出现require(“grunt”)这样的依赖，dependencies配置里边也不会写上grunt的依赖，为了说明此模块只能作为插件跑在宿主的某个版本范围下，可以配置peerDependencies：</p><pre><code>{  &quot;name&quot;: &quot;tea-latte&quot;,  &quot;version&quot;: &quot;1.3.5&quot;,  &quot;peerDependencies&quot;: {    &quot;tea&quot;: &quot;2.x&quot;  }}</code></pre><p>上面这个配置确保再npm install的时候tea-latte会和2.x版本的tea一起安装，而且它们两个的依赖关系是同级的：<br>├── tea-latte@1.3.5<br>└── tea@2.2.0<br>这个配置的目的是让npm知道，如果要使用此插件模块，请确保安装了兼容版本的宿主模块。</p><h3 id="bundledDependencies"><a href="#bundledDependencies" class="headerlink" title="bundledDependencies"></a>bundledDependencies</h3><p>上面的单词少个d，写成bundleDependencies也可以。<br>指定发布的时候会被一起打包的模块。</p><h3 id="optionalDependencies"><a href="#optionalDependencies" class="headerlink" title="optionalDependencies"></a>optionalDependencies</h3><p>如果一个依赖模块可以被使用， 同时你也希望在该模块找不到或无法获取时npm继续运行，你可以把这个模块依赖放到optionalDependencies配置中。这个配置的写法和dependencies的写法一样，不同的是这里边写的模块安装失败不会导致npm install失败。<br>当然，这种模块就需要你自己在代码中处理模块确实的情况了，例如：</p><pre><code>try {  var foo = require(&apos;foo&apos;)  var fooVersion = require(&apos;foo/package.json&apos;).version} catch (er) {  foo = null}if ( notGoodFooVersion(fooVersion) ) {  foo = null}// .. then later in your program ..if (foo) {  foo.doFooThings()}optionalDependencies 中的配置会覆盖dependencies中的配置，最好只在一个地方写。</code></pre><h3 id="engines"><a href="#engines" class="headerlink" title="engines"></a>engines</h3><p>你可以指定项目运行的node版本范围，如下：</p><pre><code>{ &quot;engines&quot; : { &quot;node&quot; : &quot;&gt;=0.10.3 &lt;0.12&quot; } }</code></pre><p>和dependencies一样，如果你不指定版本范围或者指定为*，任何版本的node都可以。<br>也可以指定一些npm版本可以正确的安装你的模块，例如：</p><pre><code>{ &quot;engines&quot; : { &quot;npm&quot; : &quot;~1.0.20&quot; } }</code></pre><p>要注意的是，除非你设置了engine-strict属性，engines属性是仅供参考的。</p><h3 id="engineStrict"><a href="#engineStrict" class="headerlink" title="engineStrict"></a>engineStrict</h3><p>注意：这个属性已经弃用，将在npm 3.0.0 版本干掉。</p><h3 id="os"><a href="#os" class="headerlink" title="os"></a>os</h3><p>可以指定你的模块只能在哪个操作系统上跑：<br>“os” : [ “darwin”, “linux” ]<br>也可以指定黑名单而不是白名单：<br>“os” : [ “!win32” ]<br>服务的操作系统是由process.platform来判断的，这个属性允许黑白名单同时存在，虽然没啥必要这样搞…</p><p>cpu</p><p>限制模块只能在某某cpu架构下运行</p><pre><code>&quot;cpu&quot; : [ &quot;x64&quot;, &quot;ia32&quot; ]</code></pre><p>同样可以设置黑名单:</p><pre><code>&quot;cpu&quot; : [ &quot;!arm&quot;, &quot;!mips&quot; ]</code></pre><p>cpu架构通过 process.arch 判断</p><h3 id="preferGlobal"><a href="#preferGlobal" class="headerlink" title="preferGlobal"></a>preferGlobal</h3><p>如果您的软件包主要用于安装到全局的命令行应用程序，那么该值设置为true ，如果它被安装在本地，则提供一个警告。实际上该配置并没有阻止用户把模块安装到本地，只是防止该模块被错误的使用引起一些问题。</p><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>如果这个属性被设置为true，npm将拒绝发布它，这是为了防止一个私有模块被无意间发布出去。如果你只想让模块被发布到一个特定的npm仓库，如一个内部的仓库，可与在下面的publishConfig中配置仓库参数。</p><h3 id="publishConfig"><a href="#publishConfig" class="headerlink" title="publishConfig"></a>publishConfig</h3><p>这个配置是会在模块发布时用到的一些值的集合。如果你不想模块被默认被标记为最新的，或者默认发布到公共仓库，可以在这里配置tag或仓库地址。</p><h3 id="DEFAULT-VALUES"><a href="#DEFAULT-VALUES" class="headerlink" title="DEFAULT VALUES"></a>DEFAULT VALUES</h3><p>npm设置了一些默认参数，如：</p><pre><code>&quot;scripts&quot;: {&quot;start&quot;: &quot;node server.js&quot;}</code></pre><p>如果模块根目录下有一个server.js文件，那么npm start会默认运行这个文件。</p><pre><code>&quot;scripts&quot;:{&quot;preinstall&quot;: &quot;node-gyp rebuild&quot;}</code></pre><p>如果模块根目录下有binding.gyp, npm将默认用node-gyp来编译preinstall的脚本</p><pre><code>&quot;contributors&quot;: [...]</code></pre><p>若模块根目录下有AUTHORS 文件，则npm会按Name (url)格式解析每一行的数据添加到contributors中，可以用#添加行注释</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NPM命令参数解析&quot;&gt;&lt;a href=&quot;#NPM命令参数解析&quot; class=&quot;headerlink&quot; title=&quot;NPM命令参数解析&quot;&gt;&lt;/a&gt;NPM命令参数解析&lt;/h1&gt;&lt;p&gt;最近在学Node，自然少不了对NPM这优秀的包管理软件的接触，这里总结一下NPM的使
      
    
    </summary>
    
      <category term="技术" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://zx19951110.github.io/ZX.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>意大利留学（一）</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2017/10/01/%E6%84%8F%E5%A4%A7%E5%88%A9%E7%95%99%E5%AD%A6/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2017/10/01/意大利留学/</id>
    <published>2017-09-30T19:57:08.000Z</published>
    <updated>2017-10-14T09:06:19.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="意大利-帕维亚大学留学-一"><a href="#意大利-帕维亚大学留学-一" class="headerlink" title="意大利-帕维亚大学留学(一)"></a>意大利-帕维亚大学留学(一)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好久没有更新博客了，因为最近没有接触和技术相关的东西，所以本篇博客就不谈技术吧，也是作为一个近期的总结。九月二十三号离开了电子科大，经过新加坡的19个小时的转机，来到了意大利米兰，又折腾到帕维亚，办了一大堆手续，也算是安定下来了吧。那我们就从几个方面，来谈一谈在意大利帕维亚的感受，同时也作为一个学长，留下一些建议给下一届的学弟学妹们。</p><h2 id="总体"><a href="#总体" class="headerlink" title="总体"></a>总体</h2><p>总的来说，意大利作为一个老牌资本主义国家和发达国家，人们生活给我的感觉还是很幸福的。然而由于难民冲击，英国脱欧，或者政府力度不足等，给这个国家带来了一些并不是很好的第一印象。首先，这边的人感觉很懒散，租房合同起草需要一周时间，办理网络需要一个半月，每天办公时间也就只有4、5个小时。这点和国内真的大相径庭。作为IT行业人员，加班、调休是很正常的一件事，我觉得如果我习惯了这边懒散的生活，回到国内肯定会适应不了快节奏生活的。</p><p>同时，慢节奏的生活，注定导致了这个国家相对中国一些建设上的不足。国际都市米兰，给我的感觉好像回到了十年二十年前的中国，旧路，有轨电车，放眼望去没有一座高楼大厦，路也很窄，没有那种双向四车道，八车道，只有发霉的欧式建筑和墙壁上乱七八糟的涂鸦。而帕维亚，这个米兰南部的小城市，也无例外。帕维亚人民母语为意大利语，只有非常少的当地人才会一点浓重意大利口音的英语。这里需要提的是，感谢谷歌爸爸。如果没有谷歌翻译和谷歌地图，真的不知该怎么活在这里。</p><p>欧洲整体的互联网行业并不是像国内那样发达，网购，网约车等在国内习以为常的O2O行业在这边几乎没有，甚至给tabacci的小姐姐使用谷歌翻译的时候，她居然觉得很惊奇。</p><p>公共秩序感觉和中国很相似，意大利人吸烟率很高，而且意大利的路或者步行街很多都是那种几百年的砖路、鹅卵石路，走在上面脚很难受，当然这是后话。意大利人也喜欢随地扔烟头，所以这些砖头、鹅卵石的缝隙中就会卡入烟头，很不美观。和新加坡那种严格用法律约束人民不同，意大利人民自由散漫。但是对外很友好。有一次在EuropeSpin中买糖但是我不认识，问了旁边一个意大利人他竟然直接给我跑去拿来了一袋糖。这边交通和中国一样也是右侧通行，不过和国内不同的是，这边的车子会礼让行人，在你还没到斑马线时就完全停住，等你完全过到马路那边才会开走。有人说意大利是西方的中国，除了家庭观念差不多，我觉得国民素质意大利人还是略胜一筹的。</p><h3 id="衣"><a href="#衣" class="headerlink" title="衣"></a>衣</h3><p>意大利的气候属于地中海气候，夏秋干燥，春冬还没有经历还不知道，不过听说是湿润多雨的。目前的气候感觉和吉林的气候很像，无论是湿度还是温度。所以一般早晚衬衫加外套。中午热了的话可以脱掉。有人说过意大利人很会打扮，根据我在米兰中央车站三个小时候车时间看行人的经验来讲，还是和中国一样的，只不过这边秃顶大叔和大胡子胖子很多。</p><h3 id="食"><a href="#食" class="headerlink" title="食"></a>食</h3><p>关于食物，这里可能要说很多。帕维亚以米饭和意大利面或通心粉为主食，根据这几天做饭或者尝试做本地食物的经验来讲，并不符合中国人的胃口。通心粉很难煮熟，淋在通心粉上面的酱以番茄为主，刚开始觉得很难吃，吃习惯了也没有觉得很难吃了。这边的米饭和中国的长粒米饭不同，这边的米要更圆一点，棱角分明，且不易熟透。前几天无论是做粥还是做干饭都感觉米没有熟。</p><p>Pizza相对于国内的必胜客之类的店来讲是要便宜太多了，大约14、5rmb可以买到一块，但是这边的Pizza特别大，上面的奶油？也是很腻很腻，可以拉成丝的那种。饿坏了的话吃起来会觉得很爽，但是吃了几口之后，你会腻的晚饭都不想吃。</p><p>中国留学生一般都是在家做饭，第一符合胃口，第二便宜。这边做菜使用橄榄油，用起来和豆油差不多。这边超市的食材价格和国内差不多，肉类可能要更便宜一点。超市里蔬菜和国内差不多但是有一些没有见过，值得一提的是有很大一部分货架是用来放专门做沙拉的蔬菜的。肉的话也和国内差不多，但是这边的肉都是用保鲜膜和泡沫盘装好的，很精致，和国内员工用刀子切不同。菜刀并没有国内的那种常见的方形的类似砍刀的菜刀，而是刀刃带有一定弧度的类似大号水果刀的很薄的刀。价格的话根据学长说，吃饭大概每个人100-200欧，这几天我们三个人的话算了一下自己做大概一顿饭10元人民币差不多。牛奶很便宜，0.6欧大概人民币5元钱可以买到一升牛奶，配上饼干当早餐也是不错的。这边的酒很便宜但是烟很贵。</p><p>如果在外面吃那就是很贵的了，一顿饭最起码要3欧甚至更高，有一次在食堂吃饭花了9欧人民币大概70元，内容和国内食堂差不多。这边的中国餐厅，日本餐厅基本都是中国人开的。价格也差不多10欧左右一顿，总体来看还是自己做饭比较划算一些。</p><p>然而意大利的咖啡还是很便宜的，但是不一定符合国人的胃口。一个小杯子，一个小盘子，一个牛角包。大概就是意大利人的早餐了。但是咖啡极苦，我反正是受不了的。</p><p>总体来讲每个月吃饭大概在100-200欧左右，但是我们还没有经历过一个月，所以还很难说。</p><h3 id="住"><a href="#住" class="headerlink" title="住"></a>住</h3><p>说道住，对于留学生来讲，住是一个很大的问题。意大利学校的宿舍普遍不好申请，很多学生选择住在校外。这样就会和中介打上交到。有很多语言很好的留学生选择去做中介。和国内不同的是，中介只是作为连接房东和学生的一个关系人。不会代收房租或者国内中介那种更过分的事情。在帕维亚住宿的话，一个人包水电网每个月大概200欧到300欧左右，学校宿舍则会更贵一些。在外面租房的话房东会为你准备好很多生活必需品比如盘子菜刀洗洁精等物品，不过用完后需要自己去补充。</p><h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>意大利的交通很贵，公交车是打票制度，如果逃票被抓住则会罚款35欧元左右。一般来讲公交票会在Tabacci这种烟店中有出售，大约1.3欧元一张，上公交车打票后会留下一个时间戳。在这个时间戳之后的一个小时内，票都算有效即使换乘。但是超过了一个小时则需要另外一张票。Pavia大学的学生可以办理公交卡，每个月5欧元，随便坐，还是很划算的。至于打车，还是很贵的。意大利的火车很迷，我到现在也没有弄懂怎么坐，总之就是到终端买票，然后去那个大电子屏幕看自己是哪个站台然后上车。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>这里就想到哪说到哪吧。首先国内的银联卡在这边有一些银行不可以用，这里要注意一下，然后这边等同于国内的身份证的文件叫税码，然后需要办理居留证明和保险等等，三四天基本就能弄完。最后，提前学一点意大利语绝对有好处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;意大利-帕维亚大学留学-一&quot;&gt;&lt;a href=&quot;#意大利-帕维亚大学留学-一&quot; class=&quot;headerlink&quot; title=&quot;意大利-帕维亚大学留学(一)&quot;&gt;&lt;/a&gt;意大利-帕维亚大学留学(一)&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; c
      
    
    </summary>
    
      <category term="杂谈" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="留学" scheme="https://zx19951110.github.io/ZX.github.io/tags/%E7%95%99%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2017/09/13/Markdown%E8%AF%AD%E6%B3%95/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2017/09/13/Markdown语法/</id>
    <published>2017-09-13T06:11:26.000Z</published>
    <updated>2017-10-29T04:37:55.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown基础语法"><a href="#Markdown基础语法" class="headerlink" title="Markdown基础语法"></a>Markdown基础语法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>啊，各位真是好久不见啦，自从拿到签证之后，回家过了一个慵懒的假期，自然也就再没有更新blog。现在回到了学校发现居然已经不会写markdown了，真是尴尬。那本文就作为一个记录性质的文章，提醒自己，也方便大家。</p><h2 id="Markdown语法的简要规则"><a href="#Markdown语法的简要规则" class="headerlink" title="Markdown语法的简要规则"></a>Markdown语法的简要规则</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。</p><pre><code># 一级标题## 二级标题### 三级标题</code></pre><p><img src="http://ww1.sinaimg.cn/large/6aee7dbbgw1effeaclhiyj20eh09cwez.jpg" alt="title"><br>以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。</p><pre><code>*12.2-3</code></pre><p><img src="http://ww4.sinaimg.cn/large/6aee7dbbgw1effew5aftij20d80bz3yw.jpg" alt="list"></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>只需要在文本前加入 &gt; 这种尖括号（大于号）即可</p><pre><code>&gt;这里是引用</code></pre><p><img src="http://ww3.sinaimg.cn/large/6aee7dbbgw1effezhonxlj20e009c3yu.jpg" alt="refer"></p><h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><p>插入链接与插入图片的语法很像，区别在一个 !号</p><p><img src="https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png" alt="baidu"><br><a href="https://baidu.com" target="_blank" rel="external">baidu</a><br>插入图片的地址需要图床，这里推荐围脖图床修复计划 与 CloudApp 的服务，生成URL地址即可。</p><pre><code>![说明](图片url)[说明](链接url)</code></pre><h3 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h3><p>Markdown 的粗体和斜体也非常简单，用两个 <em> 包含一段文本就是粗体的语法，用一个 </em> 包含一段文本就是斜体的语法。<br><strong>粗体</strong><br><em>斜体</em></p><pre><code>**粗体***斜体*</code></pre><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格是我觉得 Markdown 比较累人的地方，例子如下：</p><table><thead><tr><th>dog</th><th>bird</th><th>cat</th></tr></thead><tbody><tr><td>foo</td><td>foo</td><td>foo</td></tr><tr><td>bar</td><td>bar</td><td>bar</td></tr><tr><td>baz</td><td>baz</td><td>baz</td></tr></tbody></table><pre><code>dog | bird | cat----|------|----foo | foo  | foobar | bar  | barbaz | baz  | baz</code></pre><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>很简单 一个tab</p><pre><code>代码块</code></pre><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>三个*号</p><hr><pre><code>***</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还是图样，还是要提高自己的姿势水平</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown基础语法&quot;&gt;&lt;a href=&quot;#Markdown基础语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown基础语法&quot;&gt;&lt;/a&gt;Markdown基础语法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
      <category term="技术" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="杂谈" scheme="https://zx19951110.github.io/ZX.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Composer使用心得</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2017/07/12/Composer%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2017/07/12/Composer使用心得/</id>
    <published>2017-07-12T12:09:53.000Z</published>
    <updated>2017-10-14T09:06:45.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Composer和Yii2框架在windows下的搭建"><a href="#Composer和Yii2框架在windows下的搭建" class="headerlink" title="Composer和Yii2框架在windows下的搭建"></a>Composer和Yii2框架在windows下的搭建</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>哦啦啦啦啦啦，百度离职了五天了，这几天去办理双认证准备留学所以没有怎么更新博客，还是很怀念<br>在百度时边听jazz边写代码的日子的，最近手痒痒，打算在自己的windows系统下面搭建一个Yii2框架</p><h2 id="nginx-php"><a href="#nginx-php" class="headerlink" title="nginx+php"></a>nginx+php</h2><p>关于windows下面的php安装和nginx安装我就不再提啦，到官网下载系统对应版本的就可以，注意目前我用的是<br>nginx使用tcp方式和php-cgi交互，配置如下：</p><pre><code>fastcgi_pass   127.0.0.1:9000;fastcgi_index  index.php;fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;//这里注意配置$document_root</code></pre><p>需要注意的是，php的版本一定是5.4以上，然后下载下来的php有很多拓展并不能用，需要后续打开。<br>然后其他的指定web根目录什么的就不多讲了。</p><h2 id="composer"><a href="#composer" class="headerlink" title="composer"></a>composer</h2><p>好这就是正题了！写后端的各位是不是也很羡慕前端的npm工具呢？其实php也有包管理工具，名为Composer，<br>常用于各大php框架中例如Yii、laravel等，composer的拓展vender文件夹就是composer的包目录，我们可以通过<br>Composer的Vender拓展比如CAS等等功能。<br>废话少说，在windows下安装composer还是蛮轻松的，（在百度的时候因为用的是php5.2所以没怎么用过）。<br>推荐网站和composer镜像站，包括各个系统安装composer的方法：<br><a href="http://www.phpcomposer.com" target="_blank" rel="external">Composer中国全量镜像</a><br>好的如果按照上面的方法安装好，你会发现一个问题，我的php好像有些拓展没有开，<br>没错你需要打开<strong>ssl拓展</strong>和<strong>mbstring拓展</strong><br>如果没问题了的话，你看到的大概是这个画面<br><img src="http://www.myexception.cn/img/2014/07/05/112217521.png" alt="image"><br>ok composer安装大概就是这样，如果有问题，你不会百度啊。</p><h2 id="Yii2"><a href="#Yii2" class="headerlink" title="Yii2"></a>Yii2</h2><p>Yii2这个框架，我是又爱又恨，在百度这半年没少把精力放他身上。这个说是我最拿手的框架也不为过。<br>安装Yii2主要是通过composer安装。首先需要安装个composer的插件</p><pre><code>php composer.phar global require &quot;fxp/composer-asset-plugin:^1.2.0&quot;</code></pre><p>插件如果想要删除的话Composer请到对应的appdata目录下composer\vender删除。<br>现在选择的应用程序模板之一，开始安装 Yii 2.0。应用程序模板是一个包含Yii写的骨架Web应用程序包。<br>安装基本的应用程序模板，运行下面的命令：</p><pre><code>php composer.phar create-project yiisoft/yii2-app-basic basic 2.0.12</code></pre><p>安装高级的应用程序模板，运行下面的命令：</p><pre><code>php composer.phar create-project yiisoft/yii2-app-advanced advanced 2.0.12</code></pre><p>ok，出现下面的几个Done，就是搞定啦！然后你会发现出现了yii2的basic文件夹，配置好web根目录，访问一下<br><img src="http://d.hiphotos.baidu.com/exp/w=500/sign=3188841cd73f8794d3ff482ee21a0ead/024f78f0f736afc3dafc58c1b019ebc4b64512a5.jpg" alt="yii"><br>怎么样，惊不惊喜，意不意外，熟不熟悉！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 没什么好总结的，就是php注意开一些拓展，如果不会可以百度，不过Composer的确是一个亮点，虽然不能代替lib但是表现也够出色了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Composer和Yii2框架在windows下的搭建&quot;&gt;&lt;a href=&quot;#Composer和Yii2框架在windows下的搭建&quot; class=&quot;headerlink&quot; title=&quot;Composer和Yii2框架在windows下的搭建&quot;&gt;&lt;/a&gt;Compo
      
    
    </summary>
    
      <category term="技术" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令(更新中)</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2017/07/10/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2017/07/10/Linux常见命令-更新中/</id>
    <published>2017-07-10T12:02:22.000Z</published>
    <updated>2017-10-29T05:11:27.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux常见命令"><a href="#Linux常见命令" class="headerlink" title="Linux常见命令"></a>Linux常见命令</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>emmmmmm···作为在学校的学生能接触到Linux的机会无非就是虚拟机，而真正实战中服务器中的系统用的一般都是linux，对于程序员肯定是要熟悉的技能，而在服务器环境下，linxu可不会对用户友好到有图形化界面用鼠标键盘进行交互。所以以后通过ssh连接服务器时必然要使用linux，下面就是我这八个月中用到的linux命令，也是经常用到的命令。</p><ul><li><p>遍历目录： ll、ls</p></li><li><p>新建目录：mkdir</p></li><li><p>解压文件：tar </p><pre><code>-zxvf -z 是配合解压.GZ的 -x 解开一个包文件 -v 显示详细信息 -f 必须，表示使用归档文件</code></pre></li><li><p>删除目录：rm </p><pre><code>-rf（全部删除） 文件名</code></pre></li><li><p>切换目录：cd 目录</p></li><li><p>编辑文件：vim 文件</p><p>  编辑模式 ： i</p><pre><code>不保存退出：:q、:q!（强制）保存退出：:wq移动光标：hljk（左右下上）撤销：u查询某个字符：/字符可视化模式：ctrl+v复制整行：yy复制选定内容：可视化模式+y粘贴光标之后：p粘贴光标之前：P复制当前到行头的内容：y^ 复制当前到行尾的内容：y&amp;复制到文档尾：yG//剪切与之类似：d 没错 是删除 同时也剪切了 厉害吧</code></pre><p>   还有很多慢慢更新。。。</p></li><li><p>查看网络状态：netstat：</p><p>  netstat 命令用于显示各种网络相关信息，</p><pre><code>-a (all)显示所有选项，默认不显示LISTEN相关-t (tcp)仅显示tcp相关选项-u (udp)仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化成数字。-l 仅列出有在 Listen (监听) 的服務状态   -p 显示建立相关链接的程序名-r 显示路由信息，路由表-e 显示扩展信息，例如uid等-s 按各个协议进行统计-c 每隔一个固定时间，执行该netstat命令。提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到比如查看端口占用（8001）：netstat -apn|grep 8001列出所有端口 ：netstat -a列出所有 tcp 端口 netstat -at列出所有 udp 端口 netstat -au在 netstat 输出中显示 PID 和进程名称 netstat -p</code></pre></li><li><p>查- 找：find、locate、whereis、which、type：</p><pre><code>linux下最强大的搜索命令为”find“。它的格式为”find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;“；比如使用find命令搜索在根目录下的所有interfaces文件所在位置，命令格式为”find / -name  &apos;interfaces&apos;“（从/目录下搜索）使用locate搜索linux系统中的文件，它比find命令快。因为它查询的是数据库(/var/lib/locatedb)，数据库包含本地所有的文件信息。使用locate命令在根目录下搜索interfaces文件的命令为”locate interfaces“使用”whereis“命令可以搜索linux系统中的所有可执行文件即二进制文件。使用whereis命令搜索grep二进制文件的命令为”whereis grep“。使用which命令查看系统命令是否存在，并返回系统命令所在的位置。使用which命令查看grep命令是否存在以及存在的目录的命令为”which grep“。使用type命令查看系统中的某个命令是否为系统自带的命令。使用type命令查看cd命令是否为系统自带的命令；查看grep 是否为系统自带的命令。</code></pre></li><li><p>强制结束当前进程：ctrl+c</p></li><li><p>挂起当前进程：ctrl+z</p><pre><code>可用fg/bg操作继续前台或后台的任务,fg命令重新启动前台被中断的任务,bg命令把被中断的任务放在后台执行.</code></pre></li></ul><ul><li><p>发送EOF二进制符：ctrl+d</p></li><li><p>查看文件尾：tail -f </p><pre><code>常用于查看日志文件</code></pre></li><li><p>测试网络连接和丢包率：ping 域名</p></li><li><p>curl命令：过于强大慢慢更新</p></li><li><p>压力测试：ab -n （访问量） -c（并发数）</p></li><li><p>清屏：ctrl +l</p></li><li><p>查看系统状态：top</p><pre><code>top命令的第一行“top - 19:56:47 up 39 min,  3 users,  load average: 0.00, 0.00, 0.00”显示的内容依次为“系统当前时间 、系统到目前为止已运行的时间、当前登录系统的用户数量、系统负载(任务队列的平均长度)三个值分别为1分钟、5分钟、15分钟前到现在的平均值【这三个一般会小于1，如果持续高于5，请仔细查看那个程序影响系统的运行】”top命令的第二行“Tasks: 120 total,   2 running, 118 sleeping,   0 stopped,   0 zombie”显示的内容依次“所有启动的进程数”、“正在运行的进程数”、“挂起的进程数”、“停止的进程数”、“僵尸进程数”。top命令的第三行“Cpu(s):  0.0%us,  0.0%sy,  0.0%ni,100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st”显示的内容依次为“用户空间占用CPU百分比”、“内核空间占用CPU百分比”、“用户空间内改变过优先级的进程占用CPU百分比”、“空闲CPU百分比”、“等待输入输出CPU时间百分比”、“CPU服务于硬件中断所耗费的时间总额”、“CPU服务软中断所耗费的时间总额”、“Steal Time”top命令第四行“Mem:    508820k total,   480172k used,    28648k free,    41944k buffers”显示内容依次为“物理内存总量”、“已使用的物理内存”、“空闲物理内存”、“内核缓存内存量”。“PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND ”显示内容依次为“进程ID”、“进程所有者”、“优先级”、“nice值，负值表示高优先级，正值表示低优先级”、“进程使用的虚拟内存总量”、“进程使用的、未被换出的物理内存大小”、“共享内存大小”、“进程状态”、“上次更新到现在的CPU时间占用百分比”、“进程使用的物理内存百分比”、“进程使用CPU总时间”、“命令名、命令行”。</code></pre></li><li><p>chmod：用于改变linux系统文件或目录的访问权限。</p><pre><code>chmod [-cfvR] [--help] [--version] mode file-c 当发生改变时，报告处理信息-f 错误信息不输出-R 处理指定目录以及其子目录下的所有文件-v 运行时显示详细处理信息权限范围：u ：目录或者文件的当前的用户g ：目录或者文件的当前的群组o ：除了目录或者文件的当前用户或群组之外的用户或者群组a ：所有的用户及群组权限代号：r ：读权限，用数字4表示w ：写权限，用数字2表示x ：执行权限，用数字1表示- ：删除权限，用数字0表示如：chmod a+x log2012.logr:读入，w:写入，x:执行linux文件权限如下：例如：　　- rw- r-- r--表示log2012.log是一个普通文件；log2012.log的属主有读写权限；与log2012.log属主同组的用户只有读权限；其他用户也只有读权限。</code></pre></li><li><p>scp：拷贝远程文件</p><pre><code>对拷文件夹 (包括文件夹本身)scp -r   /home/wwwroot/www/charts/util root@192.168.1.65:/home/wwwroot/limesurvey_back/scp对拷文件夹下所有文件 (不包括文件夹本身)scp   /home/wwwroot/www/charts/util/* root@192.168.1.65:/home/wwwroot/limesurvey_back/scp 对拷文件并重命名scp   /home/wwwroot/www/charts/util/a.txt root@192.168.1.65:/home/wwwroot/limesurvey_back/scp/b.text</code></pre></li><li><p>sudo：使普通用户获取root权限命令，如：sudo yum install pcre（也许要输入密码）</p></li><li><p>source：执行脚本</p><pre><code>source命令与shell scripts的区别是，source在当前bash环境下执行命令，而scripts是启动一个子shell来执行命令。这样如果把设置环境变量（或alias等等）的命令写进scripts中，就只会影响子shell,无法改变当前的BASH,所以通过文件（命令列）设置环境变量时，要用source 命令。source命令(从 C Shell 而来)是bash shell的内置命令。点命令，就是个点符号，(从Bourne Shell而来)是source的另一名称。同样的，当前脚本中配置的变量也将作为脚本的环境，source(或点)命令通常用于重新执行刚修改的初始化文档，如 .bash_profile 和 .profile 等等。</code></pre></li><li><p>ps：查看进程 和管道符|grep一起用，如ps -aux|grep xxx（匹配端口或者命令）</p><pre><code>常用ps aux|grep 任务名 用来查找进程1）ps a 显示现行终端机下的所有程序，包括其他用户的程序。2）ps -A   显示所有程序。3）ps c    列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。4）ps -e  此参数的效果和指定&quot;A&quot;参数相同。5）ps e   列出程序时，显示每个程序所使用的环境变量。6）ps f    用ASCII字符显示树状结构，表达程序间的相互关系。7）ps -H    显示树状结构，表示程序间的相互关系。8）ps -N   显示所有的程序，除了执行ps指令终端机下的程序之外。9）ps s     采用程序信号的格式显示程序状况。10）ps S     列出程序时，包括已中断的子程序资料。11）ps -t &lt;终端机编号&gt; 　指定终端机编号，并列出属于该终端机的程序的状况。12）ps u 　 以用户为主的格式来显示程序状况。13）ps x 　 显示所有程序，不以终端机来区分。14）ps -l     較長,較詳細的顯示該PID的信息列表如下:USER  PID %CPU %MEM   VSZ  RSS  TTY  STAT START TIME COMMANDUSER 进程的属主；PID   进程的ID；PPID    父进程；%CPU   进程占用的CPU百分比；%MEM  占用内存的百分比；NI        进程的NICE值，数值大，表示较少占用CPU时间；VSZ     該进程使用的虚拟內存量（KB）；RSS     該進程占用的固定內存量（KB）（驻留中页的数量）；TTY     該進程在那個終端上運行（登陸者的終端位置），若與終端無關，則顯示（？）。若為pts/0等，則表示由網絡連接主機進程WCHAN  當前進程是否正在進行，若為-表示正在進行；START   該進程被觸發启动时间；TIME      該进程實際使用CPU運行的时间；COMMAND   命令的名称和参数；ping：查询是否可连接 如ping www.baidu.com（ip）</code></pre></li><li><p>grep：很强大的搜索匹配命令 grep xxx</p><pre><code>－c：只输出匹配行的计数。－I：不区分大 小写(只适用于单字符)。－h：查询多文件时不显示文件名。－l：查询多文件时只输出包含匹配字符的文件名。－n：显示匹配行及 行号。－s：不显示不存在或无匹配文本的错误信息。－v：显示不包含匹配文本的所有行。pattern正则表达式主要参数：\： 忽略正则表达式中特殊字符的原有含义。^：匹配正则表达式的开始行。$: 匹配正则表达式的结束行。\&lt;：从匹配正则表达 式的行开始。\&gt;：到匹配正则表达式的行结束。[ ]：单个字符，如[A]即A符合要求 。[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。。：所有的单个字符。* ：有字符，长度可以为0。实例：$ grep ‘test’ d*显示所有以d开头的文件中包含 test的行。$ grep ‘test’ aa bb cc显示在aa，bb，cc文件中匹配test的行。$ grep ‘[a-z]\{5\}’ aa显示所有包含每个字符串至少有5个连续小写字符的字符串的行。$ grep ‘w\(es\)t.*\1′ aa如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符(.*)，这些字符后面紧跟着 另外一个es(\1)，找到就显示该行。如果用egrep或grep -E，就不用”\”号进行转义，直接写成’w(es)t.*\1′就可以了。</code></pre></li><li><p>make: 安装应用</p><pre><code>./configure是用来检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本。make是用来编译的，它从Makefile中读取指令，然后编译。make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。AUTOMAKE和AUTOCONF是非常有用的用来发布C程序的东西。-----1、configure，这一步一般用来生成 Makefile，为下一步的编译做准备，你可以通过在 configure 后加上参数来对安装进行控制，比如代码:./configure –prefix=/usr 意思是将该软件安装在 /usr 下面，执行文件就会安装在 /usr/bin （而不是默认的 /usr/local/bin),资源文件就会安装在 /usr/share（而不是默认的/usr/local/share）。同时一些软件的配置文件你可以通过指定 –sys-config= 参数进行设定。有一些软件还可以加上 –with、–enable、–without、–disable 等等参数对编译加以控制，你可以通过允许 ./configure –help 察看详细的说明帮助。2、make，这一步就是编译，大多数的源代码包都经过这一步进行编译（当然有些perl或python编写的软件需要调用perl或python来进行编译）。如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行），然后你可以向开发者提交 bugreport（一般在 INSTALL 里有提交地址），或者你的系统少了一些依赖库等，这些需要自己仔细研究错误代码。3、make insatll，这条命令来进行安装（当然有些软件需要先运行 make check 或 make test 来进行一些测试），这一步一般需要你有 root 权限（因为要向系统写入文件）。-----Linux的用户可能知道，在Linux下安装一个应用程序时，一般先运行脚本configure，然后用make来编译源程序，在运行make install，最后运行make clean删除一些临时文件。使用上述三个自动工具，就可以生成configure脚本。运行configure脚本，就可以生成Makefile文件，然后就可以运行make、make install和make clean。configure是一个shell脚本，它可以自动设定源程序以符合各种不同平台上Unix系统的特性，并且根据系统叁数及环境产生合适的Makefile文件或是C的头文件(header file)，让源程序可以很方便地在这些不同的平台上被编译连接。这时，就可运行configure脚本了，运行configure脚本，就可产生出符合GNU规范的Makefile文件了：$ ./configure到此时，就可以运行make进行编译，在运行make install进行安装了，最后运行make clean删除临时文件。$ make$ make install           (注：运行这个要有足够的权限)$ make clean利用configure所产生的Makefile文件有几个预设的目标可供使用，其中几个重要的简述如下：make all：产生我们设定的目标，即此范例中的可执行文件。只打make也可以，此时会开始编译原始码，然后连结，并且产生可执行文件。make clean：清除编译产生的可执行文件及目标文件(object file，*.o)。make distclean：除了清除可执行文件和目标文件外，把configure所产生的Makefile也清除掉。make install：将程序安装至系统中。如果原始码编译无误，且执行结果正确，便可以把程序安装至系统预设的可执行文件存放路径。如果用bin_PROGRAMS宏的话，程序会被安装至/usr/local/bin这个目录。make dist：将程序和相关的档案包装成一个压缩文件以供发布。执行完在目录下会产生一个以PACKAGE-VERSION.tar.gz为名称的文件。 PACKAGE和VERSION这两个变数是根据configure.in文件中AM_INIT_AUTOMAKE(PACKAGE，VERSION)的定义。在此范例中会产生test-1.0.tar.gz的档案。make distcheck：和make dist类似，但是加入检查包装后的压缩文件是否正常。这个目标除了把程序和相关文件包装成tar.gz文件外，还会自动把这个压缩文件解开，执行 configure，并且进行make all 的动作，确认编译无误后，会显示这个tar.gz文件可供发布了。这个检查非常有用，检查过关的包，基本上可以给任何一个具备GNU开发环境-的人去重新编译。</code></pre></li><li><p>sed：用于修改文件（好用）</p><pre><code>不需要使用vim修改文件，直接sed -i &apos;s/原始内容/替换内容/&apos;就可以，很多参数如下：a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！-i 用于保存</code></pre></li><li><p>crontab： 定时任务（好用）</p><pre><code>crontab -l 列出所有定时任务crontab -e新增定时任务crontab -r删除所有定时任务（删除一条请去编辑）编辑格式：*　　*　　*　　*　　*　　command 分　时　日　月　周　命令   “*”代表取值范围内的数字,  “/”代表”每”,  “-”代表从某个数字到某个数字,  “,”分开几个离散的数字  注意，无论是调用的脚本还是在定时任务编辑中，一定要使用绝对路径</code></pre></li></ul><h2 id="慢慢更新中···"><a href="#慢慢更新中···" class="headerlink" title="慢慢更新中···"></a>慢慢更新中···</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux常见命令&quot;&gt;&lt;a href=&quot;#Linux常见命令&quot; class=&quot;headerlink&quot; title=&quot;Linux常见命令&quot;&gt;&lt;/a&gt;Linux常见命令&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="技术" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zx19951110.github.io/ZX.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>前端跨域方案</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2017/07/09/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2017/07/09/前端跨域方案/</id>
    <published>2017-07-09T05:29:10.000Z</published>
    <updated>2017-10-14T09:06:19.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端几种跨域方案"><a href="#前端几种跨域方案" class="headerlink" title="前端几种跨域方案"></a>前端几种跨域方案</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在百度实习的时候曾经遇到过一些多服务器交互的问题，多台服务器不同域名，请求其他服务器数据时肯定是有一些问题的。<br>受浏览器同源策略的限制，本域的js不能操作其他域的页面对象（比如DOM）。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。<br>这里需要明确的一点是：所谓的域跟js的存放服务器没有关系，比如baidu.com的页面加载了google.com的js，那么此js的所在域是baidu.com而不是google.com。也就是说，此时该js能操作baidu.com的页面对象，而不能操作google.com的页面对象。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="单向跨域（一般用于获取数据）"><a href="#单向跨域（一般用于获取数据）" class="headerlink" title="单向跨域（一般用于获取数据）"></a>单向跨域（一般用于获取数据）</h3><ul><li><p>使用JSONP跨域</p><p>  原理：因为通过script标签引入的js是不受同源策略的限制的（正如前文提到的baidu.com的页面加载了google.com的js）。所以我们可以通过script标签引入一个js或者是一个其他后缀形式（如PHP，jsp等）的文件，此文件返回一个js函数的调用，如返回JSONP_getUsers([“paco”,”john”,”lili”])，也就是说此文件返回的结果调用了JSONP_getUsers函数，并且把[“paco”,”john”,”lili”]传进去，这个[“paco”,”john”,”lili”]是一个用户列表。那么如果此时我们的页面中有一个JSONP_getUsers函数，那么JSONP_getUsers就被调用到，并且传入了用户列表。此时就实现了在本域获取其他域数据的功能，也就是跨域。<br>  简单来讲呢，就是前端首先实现一个方法，方法名要和服务器端规定好，然后后端传来数据为函数名并且携带参数，具体参数由前端处理。<br>  例如：<br>  前端引入远程js并定义好JSONP_getUsers函数，注意需要先定义好JSONP_getUsers函数，避免在远程js加载完成并调用JSONP_getUsers时，此函数不存在：</p><pre><code>//本域为baidu.com  &lt;script&gt;  function JSONP_getUsers(users){//定义好处理函数名      console.dir(users);  }  &lt;/script&gt;  //加载google.com的getUsers.php  &lt;script src=&quot;http://www.google.com/getUsers.php&quot;&gt;&lt;/script&gt; //script标签跨域</code></pre><p>  服务端代码如下：</p><pre><code>&lt;?php&gt;  echo &apos;JSONP_getUsers([&quot;paco&quot;,&quot;john&quot;,&quot;lili&quot;])&apos;;//返回一个js函数的调用  ?&gt;  </code></pre><p>  为什么script标签引入的文件不受同源策略的限制？因为script标签引入的文件内容是不能够被客户端的js获取到的，不会影响到被引用文件的安全，所以没必要使script标签引入的文件遵循浏览器的同源策略。而通过ajax加载的文件内容是能够被客户端js获取到的，所以ajax必须遵循同源策略，否则被引入文件的内容会泄漏或者存在其他风险。</p><p>  JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求（虽然采用post+动态生成iframe是可以达到post跨域的目的，但这样做是一个比较极端的方式，不建议采用）。一般get请求能完成所有功能。比如如果需要给其他域服务器传送参数可以在请求后挂参数（注意不要挂隐私数据）</p></li><li><p>动态创建script标签</p><p>  这种方法其实是JSONP跨域的简化版，JSONP只是在此基础上加入了回调函数。<br>  比如上例中的getUsers.php返回的如果不是一个js函数的调用，而是一个js变量，如：</p><pre><code>&lt;?php&gt;      echo &apos;var users=[&quot;paco&quot;,&quot;john&quot;,&quot;lili&quot;]&apos;;//返回一个js变量users  ?&gt;  </code></pre><p>  那么在本域下就可以取到data变量，这里需要注意判断script节点是否加载完毕，如：</p><pre><code>js.onload = js.onreadystatechange = function() {      if (!this.readyState || this.readyState === &apos;loaded&apos; || this.readyState === &apos;complete&apos;) {          console.log(users);//此处取出其他域的数据          js.onload = js.onreadystatechange = null;      }  };  </code></pre></li><li><p>后端加跨域header</p><p>  这部需要在服务器这边处理</p><p>  nginx：</p><pre><code>add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;;</code></pre><p>  php:</p><pre><code>header(&quot;Access-Control-Allow-Origin: http://www.baidu.com&quot;);//表示允许baidu.com跨域请求本文件  </code></pre></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>跨域非难事，只怕有心人</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端几种跨域方案&quot;&gt;&lt;a href=&quot;#前端几种跨域方案&quot; class=&quot;headerlink&quot; title=&quot;前端几种跨域方案&quot;&gt;&lt;/a&gt;前端几种跨域方案&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="技术" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://zx19951110.github.io/ZX.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>php使用Redis</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2017/07/09/php%E4%BD%BF%E7%94%A8Redis/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2017/07/09/php使用Redis/</id>
    <published>2017-07-09T02:27:55.000Z</published>
    <updated>2017-10-14T09:06:25.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP使用redis拓展"><a href="#PHP使用redis拓展" class="headerlink" title="PHP使用redis拓展"></a>PHP使用redis拓展</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>mysql一直作为数据库的情况下在小并发网站上还是没有问题的，但是一旦出现高并发的情况，mysql服务器连接过多，<br>必然会导致IO瓶颈，速度越来越慢。那怎么解决呢？大家都知道，相比于硬盘，从内存中操作时最快的，如果我们把数<br>据存到内存中作为缓存，每次查询命中内存，则不去mysql的硬盘层去查找，这样既可以提高速度，也降低了mysql的连接数。<br>目前内存数据库有很多，这里不进行列出。由于百度使用的是Redis，那我们就聊一聊redis。</p><h3 id="Redis的安装："><a href="#Redis的安装：" class="headerlink" title="Redis的安装："></a>Redis的安装：</h3><p>百度良心包管理工具Jumbo直接install就可以。连接不到百度内网可以参考这篇博客<a href="http://www.cnblogs.com/codersay/p/4301677.html" target="_blank" rel="external">http://www.cnblogs.com/codersay/p/4301677.html</a><br>这里不做多说。</p><h3 id="小坑注意："><a href="#小坑注意：" class="headerlink" title="小坑注意："></a>小坑注意：</h3><p>redis使用的是tcp连接，首先启动服务redis-server时后面要加配置文件路径如</p><pre><code>redis-server ./.jumbo/etc/redis.conf</code></pre><p>然后调用命令:</p><pre><code>redis-cli -h 127.0.0.1 -p 6379</code></pre><h2 id="正题："><a href="#正题：" class="headerlink" title="正题："></a>正题：</h2><p>phpredis是php的一个扩展，效率是相当高有链表排序功能，对创建内存级的模块业务关系<br>很有用;以下是redis官方提供的命令使用技巧:<br>下载地址如下：<br><a href="https://github.com/owlient/phpredis（支持redis" target="_blank" rel="external">https://github.com/owlient/phpredis（支持redis</a> 2.0.4）</p><p>Redis::__construct构造函数</p><pre><code>$redis = new Redis();</code></pre><p>connect, open 链接redis服务<br>参数<br>host: string，服务地址<br>port: int,端口号<br>timeout: float,链接时长 (可选, 默认为 0 ，不限链接时间)<br>注: 在redis.conf中也有时间，默认为300</p><pre><code>$redis-&gt;connect(&apos;127.0.0.1&apos;,6379,0);</code></pre><p>pconnect, popen 不会主动关闭的链接<br>参考上面</p><p>setOption 设置redis模式</p><p>getOption 查看redis设置的模式</p><p>ping 查看连接状态</p><pre><code>// 不序列化数据!$redis-&gt;setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_NONE);// 使⽤用内置序列化/不序列化$redis-&gt;setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_PHP); //使⽤用igbinary系列化/ 不序列化$redis-&gt;setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_IGBINARY); //使⽤用⾃自定义前缀的所有键!$redis-&gt;setOption(Redis::OPT_PREFIX, &apos;myAppName:&apos;); </code></pre><p>get 得到某个key的值（string值）<br>如果该key不存在，return false</p><pre><code>$redis-&gt;get(&quot;test&quot;);</code></pre><p>set 写入key 和 value（string值）<br>如果写入成功，return ture</p><pre><code>$redis-&gt;set（&apos;test&apos;,123）;</code></pre><p>setex 带生存时间的写入值</p><pre><code>$redis-&gt;setex(&apos;key&apos;, 3600, &apos;value&apos;); // sets key → value, with 1h TTL.</code></pre><p>setnx 判断是否重复的，写入值</p><pre><code>$redis-&gt;setnx(&apos;key&apos;, &apos;value&apos;);</code></pre><p>delete  删除指定key的值<br>返回已经删除key的个数（长整数）</p><pre><code>$redis-&gt;delete(&apos;key1&apos;, &apos;key2&apos;);$redis-&gt;delete(array(&apos;key3&apos;, &apos;key4&apos;, &apos;key5&apos;));</code></pre><p>ttl<br>得到一个key的生存时间</p><pre><code>$redis-&gt;ttl(&apos;test&apos;);</code></pre><p>persist<br>移除生存时间到期的key<br>如果key到期 true 如果不到期 false</p><pre><code>$redis-&gt;persist(&apos;test&apos;);</code></pre><p>mset （redis版本1.1以上才可以用）<br>同时给多个key赋值</p><pre><code>$redis-&gt;mset(array(&apos;key0&apos; =&gt; &apos;value0&apos;, &apos;key1&apos; =&gt; &apos;value1&apos;));</code></pre><p>multi, exec, discard<br>进入或者退出事务模式<br>参数可选Redis::MULTI或Redis::PIPELINE. 默认是 Redis::MULTI<br>Redis::MULTI：将多个操作当成一个事务执行<br>Redis::PIPELINE:让（多条）执行命令简单的，更加快速的发送给服务器，但是没有任何原子性的保证<br>discard:删除一个事务<br>返回值<br>multi()，返回一个redis对象，并进入multi-mode模式，一旦进入multi-mode模式，以后调用的所有方法都会返回相同的对象，只到exec(）方法被调用。</p><p>watch, unwatch （代码测试后，不能达到所说的效果）<br>监测一个key的值是否被其它的程序更改。如果这个key在watch 和 exec （方法）间被修改，这个 MULTI/EXEC 事务的执行将失败（return false）<br>unwatch  取消被这个程序监测的所有key<br>参数，一对key的列表</p><pre><code>$redis-&gt;watch(&apos;x&apos;);$ret = $redis-&gt;multi() -&gt;incr(&apos;x&apos;) -&gt;exec();</code></pre><p>subscribe *<br>方法回调。注意，该方法可能在未来里发生改变</p><p>publish *<br>发表内容到某一个通道。注意，该方法可能在未来里发生改变</p><p>exists<br>判断key是否存在。存在 true 不在 false</p><pre><code>$redis-&gt;exists(&apos;test&apos;);</code></pre><p>incr, incrBy<br>key中的值进行自增1，如果填写了第二个参数，者自增第二个参数所填的值</p><pre><code>$redis-&gt;incr(&apos;key1&apos;);$redis-&gt;incrBy(&apos;key1&apos;, 10);</code></pre><p>decr, decrBy<br>做减法，使用方法同incr</p><p>getMultiple<br>传参<br>由key组成的数组<br>返回参数<br>如果key存在返回value，不存在返回false</p><pre><code>$redis-&gt;set(&apos;key1&apos;, &apos;value1&apos;); $redis-&gt;set(&apos;key2&apos;, &apos;value2&apos;); $redis-&gt;set(&apos;key3&apos;, &apos;value3&apos;); $redis-&gt;getMultiple(array(&apos;key1&apos;, &apos;key2&apos;, &apos;key3&apos;));$redis-&gt;lRem(&apos;key1&apos;, &apos;A&apos;, 2);$redis-&gt;lRange(&apos;key1&apos;, 0, -1);</code></pre><h4 id="list相关操作"><a href="#list相关操作" class="headerlink" title="list相关操作"></a>list相关操作</h4><p>lPush<br>在名称为key的list左边（头）添加一个值为value的 元素</p><pre><code>$redis-&gt;lPush(key, value);</code></pre><p>rPush<br>在名称为key的list右边（尾）添加一个值为value的 元素</p><pre><code>$redis-&gt;rPush(key, value);</code></pre><p>lPushx/rPushx<br>在名称为key的list左边(头)/右边（尾）添加一个值为value的元素,如果value已经存在，则不添加\</p><pre><code>$redis-&gt;lPushx(key, value);</code></pre><p>lPop/rPop<br>输出名称为key的list左(头)起/右（尾）起的第一个元素，删除该元素</p><pre><code>$redis-&gt;lPop(&apos;key&apos;);</code></pre><p>blPop/brPop<br>lpop命令的block版本。即当timeout为0时，若遇到名称为key i的list不存在或该list为空，则命令结束。如果timeout&gt;0，则遇到上述情况时，等待timeout秒，如果问题没有解决，则对keyi+1开始的list执行pop操作</p><pre><code>$redis-&gt;blPop(&apos;key1&apos;, &apos;key2&apos;, 10);</code></pre><p>lSize<br>返回名称为key的list有多少个元素</p><pre><code>$redis-&gt;lSize(&apos;key&apos;);</code></pre><p>lIndex, lGet<br>返回名称为key的list中index位置的元素</p><pre><code>$redis-&gt;lGet(&apos;key&apos;, 0);</code></pre><p>lSet<br>给名称为key的list中index位置的元素赋值为value</p><pre><code>$redis-&gt;lSet(&apos;key&apos;, 0, &apos;X&apos;);</code></pre><p>lRange, lGetRange<br>返回名称为key的list中start至end之间的元素（end为 -1 ，返回所有）</p><pre><code>$redis-&gt;lRange(&apos;key1&apos;, 0, -1);</code></pre><p>lTrim, listTrim<br>截取名称为key的list，保留start至end之间的元素</p><pre><code>$redis-&gt;lTrim(&apos;key&apos;, start, end);</code></pre><p>lRem, lRemove<br>删除count个名称为key的list中值为value的元素。count为0，删除所有值为value的元素，count&gt;0从头至尾删除count个值为value的元素，count&lt;0从尾到头删除|count|个值为value的元素</p><pre><code>$redis-&gt;lRem(&apos;key&apos;, &apos;A&apos;, 2);</code></pre><p>lInsert<br>在名称为为key的list中，找到值为pivot 的value，并根据参数Redis::BEFORE | Redis::AFTER，来确定，newvalue 是放在 pivot 的前面，或者后面。如果key不存在，不会插入，如果 pivot不存在，return -1</p><pre><code>$redis-&gt;delete(&apos;key1&apos;); $redis-&gt;lInsert(&apos;key1&apos;, Redis::AFTER, &apos;A&apos;, &apos;X&apos;); $redis-&gt;lPush(&apos;key1&apos;, &apos;A&apos;); $redis-&gt;lPush(&apos;key1&apos;, &apos;B&apos;); $redis-&gt;lPush(&apos;key1&apos;, &apos;C&apos;); $redis-&gt;lInsert(&apos;key1&apos;, Redis::BEFORE, &apos;C&apos;, &apos;X&apos;);$redis-&gt;lRange(&apos;key1&apos;, 0, -1);$redis-&gt;lInsert(&apos;key1&apos;, Redis::AFTER, &apos;C&apos;, &apos;Y&apos;);$redis-&gt;lRange(&apos;key1&apos;, 0, -1);$redis-&gt;lInsert(&apos;key1&apos;, Redis::AFTER, &apos;W&apos;, &apos;value&apos;);</code></pre><p>rpoplpush<br>返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部</p><pre><code>$redis-&gt;delete(&apos;x&apos;, &apos;y&apos;);$redis-&gt;lPush(&apos;x&apos;, &apos;abc&apos;); $redis-&gt;lPush(&apos;x&apos;, &apos;def&apos;); $redis-&gt;lPush(&apos;y&apos;, &apos;123&apos;); $redis-&gt;lPush(&apos;y&apos;, &apos;456&apos;); // move the last of x to the front of y. var_dump($redis-&gt;rpoplpush(&apos;x&apos;, &apos;y&apos;));var_dump($redis-&gt;lRange(&apos;x&apos;, 0, -1));var_dump($redis-&gt;lRange(&apos;y&apos;, 0, -1)); string(3) &quot;abc&quot; array(1) { [0]=&gt; string(3) &quot;def&quot; } array(3) { [0]=&gt; string(3) &quot;abc&quot; [1]=&gt; string(3) &quot;456&quot; [2]=&gt; string(3) &quot;123&quot; }</code></pre><h4 id="SET操作相关"><a href="#SET操作相关" class="headerlink" title="SET操作相关"></a>SET操作相关</h4><p>sAdd<br>向名称为key的set中添加元素value,如果value存在，不写入，return false</p><pre><code>$redis-&gt;sAdd(key , value);</code></pre><p>sRem, sRemove<br>删除名称为key的set中的元素value</p><pre><code>$redis-&gt;sAdd(&apos;key1&apos; , &apos;set1&apos;);$redis-&gt;sAdd(&apos;key1&apos; , &apos;set2&apos;);$redis-&gt;sAdd(&apos;key1&apos; , &apos;set3&apos;);$redis-&gt;sRem(&apos;key1&apos;, &apos;set2&apos;);</code></pre><p>sMove<br>将value元素从名称为srckey的集合移到名称为dstkey的集合</p><pre><code>$redis-&gt;sMove(seckey, dstkey, value);</code></pre><p>sIsMember, sContains<br>名称为key的集合中查找是否有value元素，有ture 没有 false</p><pre><code>$redis-&gt;sIsMember(key, value);</code></pre><p>sCard, sSize<br>返回名称为key的set的元素个数</p><p>sPop<br>随机返回并删除名称为key的set中一个元素</p><p>sRandMember<br>随机返回名称为key的set中一个元素，不删除</p><p>sInter<br>求交集</p><p>sInterStore<br>求交集并将交集保存到output的集合<br>$redis-&gt;sInterStore(‘output’, ‘key1’, ‘key2’, ‘key3’)</p><p>sUnion<br>求并集<br>$redis-&gt;sUnion(‘s0’, ‘s1’, ‘s2’);<br>s0,s1,s2 同时求并集</p><p>sUnionStore<br>求并集并将并集保存到output的集合<br>$redis-&gt;sUnionStore(‘output’, ‘key1’, ‘key2’, ‘key3’)；</p><p>sDiff<br>求差集</p><p>sDiffStore<br>求差集并将差集保存到output的集合</p><p>sMembers, sGetMembers<br>返回名称为key的set的所有元素</p><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>排序，分页等<br>参数</p><pre><code>&apos;by&apos; =&gt; &apos;some_pattern_*&apos;,&apos;limit&apos; =&gt; array(0, 1),&apos;get&apos; =&gt; &apos;some_other_pattern_*&apos; or an array of patterns,&apos;sort&apos; =&gt; &apos;asc&apos; or &apos;desc&apos;,&apos;alpha&apos; =&gt; TRUE,&apos;store&apos; =&gt; &apos;external-key&apos;</code></pre><p>例子</p><pre><code>$redis-&gt;delete(&apos;s&apos;); $redis-&gt;sadd(&apos;s&apos;, 5); $redis-&gt;sadd(&apos;s&apos;, 4); $redis-&gt;sadd(&apos;s&apos;, 2); $redis-&gt;sadd(&apos;s&apos;, 1); $redis-&gt;sadd(&apos;s&apos;, 3);var_dump($redis-&gt;sort(&apos;s&apos;)); // 1,2,3,4,5var_dump($redis-&gt;sort(&apos;s&apos;, array(&apos;sort&apos; =&gt; &apos;desc&apos;))); // 5,4,3,2,1var_dump($redis-&gt;sort(&apos;s&apos;, array(&apos;sort&apos; =&gt; &apos;desc&apos;, &apos;store&apos; =&gt; &apos;out&apos;))); // (int)5</code></pre><h4 id="string命令"><a href="#string命令" class="headerlink" title="string命令"></a>string命令</h4><p>getSet<br>返回原来key中的值，并将value写入key</p><pre><code>$redis-&gt;set(&apos;x&apos;, &apos;42&apos;);$exValue = $redis-&gt;getSet(&apos;x&apos;, &apos;lol&apos;); // return &apos;42&apos;, replaces x by &apos;lol&apos;$newValue = $redis-&gt;get(&apos;x&apos;)&apos; // return &apos;lol&apos;</code></pre><p>append<br>string，名称为key的string的值在后面加上value</p><pre><code>$redis-&gt;set(&apos;key&apos;, &apos;value1&apos;);$redis-&gt;append(&apos;key&apos;, &apos;value2&apos;);$redis-&gt;get(&apos;key&apos;);</code></pre><p>getRange （方法不存在）<br>返回名称为key的string中start至end之间的字符</p><pre><code>$redis-&gt;set(&apos;key&apos;, &apos;string value&apos;);$redis-&gt;getRange(&apos;key&apos;, 0, 5);$redis-&gt;getRange(&apos;key&apos;, -5, -1);</code></pre><p>setRange （方法不存在）<br>改变key的string中start至end之间的字符为value</p><pre><code>$redis-&gt;set(&apos;key&apos;, &apos;Hello world&apos;);$redis-&gt;setRange(&apos;key&apos;, 6, &quot;redis&quot;);$redis-&gt;get(&apos;key&apos;);</code></pre><p>strlen<br>得到key的string的长度</p><pre><code>$redis-&gt;strlen(&apos;key&apos;);</code></pre><p>getBit/setBit<br>返回2进制信息</p><h4 id="zset（sorted-set）操作相关"><a href="#zset（sorted-set）操作相关" class="headerlink" title="zset（sorted set）操作相关"></a>zset（sorted set）操作相关</h4><p>zAdd(key, score, member)：向名称为key的zset中添加元素member，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。</p><pre><code>$redis-&gt;zAdd(&apos;key&apos;, 1, &apos;val1&apos;);$redis-&gt;zAdd(&apos;key&apos;, 0, &apos;val0&apos;);$redis-&gt;zAdd(&apos;key&apos;, 5, &apos;val5&apos;);$redis-&gt;zRange(&apos;key&apos;, 0, -1); // array(val0, val1, val5)</code></pre><p>zRange(key, start, end,withscores)：返回名称为key的zset（元素已按score从小到大排序）中的index从start到end的所有元素</p><pre><code>$redis-&gt;zAdd(&apos;key1&apos;, 0, &apos;val0&apos;);$redis-&gt;zAdd(&apos;key1&apos;, 2, &apos;val2&apos;);$redis-&gt;zAdd(&apos;key1&apos;, 10, &apos;val10&apos;);$redis-&gt;zRange(&apos;key1&apos;, 0, -1); // with scores $redis-&gt;zRange(&apos;key1&apos;, 0, -1, true);</code></pre><p>zDelete, zRem<br>zRem(key, member) ：删除名称为key的zset中的元素member</p><pre><code>$redis-&gt;zAdd(&apos;key&apos;, 0, &apos;val0&apos;);$redis-&gt;zAdd(&apos;key&apos;, 2, &apos;val2&apos;);$redis-&gt;zAdd(&apos;key&apos;, 10, &apos;val10&apos;);$redis-&gt;zDelete(&apos;key&apos;, &apos;val2&apos;);$redis-&gt;zRange(&apos;key&apos;, 0, -1); </code></pre><p>zRevRange(key, start, end,withscores)：返回名称为key的zset（元素已按score从大到小排序）中的index从start到end的所有元素.withscores: 是否输出socre的值，默认false，不输出</p><pre><code>$redis-&gt;zAdd(&apos;key&apos;, 0, &apos;val0&apos;);$redis-&gt;zAdd(&apos;key&apos;, 2, &apos;val2&apos;);$redis-&gt;zAdd(&apos;key&apos;, 10, &apos;val10&apos;);$redis-&gt;zRevRange(&apos;key&apos;, 0, -1); // with scores $redis-&gt;zRevRange(&apos;key&apos;, 0, -1, true);</code></pre><p>zRangeByScore, zRevRangeByScore<br>返回名称为key的zset中score &gt;= star且score &lt;= end的所有元素</p><pre><code>$redis-&gt;zRangeByScore(key, star, end, array(withscores， limit ));</code></pre><p>zCount<br>返回名称为key的zset中score &gt;= star且score &lt;= end的所有元素的个数</p><pre><code>$redis-&gt;zCount(key, star, end);</code></pre><p>zRemRangeByScore, zDeleteRangeByScore<br>删除名称为key的zset中score &gt;= star且score &lt;= end的所有元素，返回删除个数</p><pre><code>$redis-&gt;zRemRangeByScore(&apos;key&apos;, star, end);</code></pre><p>zSize, zCard<br>返回名称为key的zset的所有元素的个数</p><p>zScore<br>返回名称为key的zset中元素val2的score</p><pre><code>$redis-&gt;zScore(key, val2);</code></pre><p>zRank, zRevRank<br>返回名称为key的zset（元素已按score从小到大排序）中val元素的rank（即index，从0开始），若没有val元素，返回“null”。zRevRank 是从大到小排序</p><pre><code>$redis-&gt;zRevRank(key, val);</code></pre><p>zIncrBy<br>如果在名称为key的zset中已经存在元素member，则该元素的score增加increment；否则向集合中添加该元素，其score的值为increment</p><pre><code>$redis-&gt;zIncrBy(&apos;key&apos;, increment, &apos;member&apos;);</code></pre><p>zUnion/zInter<br>参数</p><pre><code>keyOutputarrayZSetKeysarrayWeightsaggregateFunction Either &quot;SUM&quot;, &quot;MIN&quot;, or &quot;MAX&quot;: defines the behaviour to use on duplicate entries during the zUnion.</code></pre><p>对N个zset求并集和交集，并将最后的集合保存在dstkeyN中。对于集合中每一个元素的score，在进行AGGREGATE运算前，都要乘以对于的WEIGHT参数。如果没有提供WEIGHT，默认为1。默认的AGGREGATE是SUM，即结果集合中元素的score是所有集合对应元素进行SUM运算的值，而MIN和MAX是指，结果集合中元素的score是所有集合对应元素中最小值和最大值。</p><h4 id="Hash操作"><a href="#Hash操作" class="headerlink" title="Hash操作"></a>Hash操作</h4><p>hSet<br>向名称为h的hash中添加元素key1—&gt;hello</p><pre><code>$redis-&gt;hSet(&apos;h&apos;, &apos;key1&apos;, &apos;hello&apos;);</code></pre><p>hGet<br>返回名称为h的hash中key1对应的value（hello）</p><pre><code>$redis-&gt;hGet(&apos;h&apos;, &apos;key1&apos;);</code></pre><p>hLen<br>返回名称为h的hash中元素个数</p><pre><code>$redis-&gt;hLen(&apos;h&apos;);</code></pre><p>hDel<br>删除名称为h的hash中键为key1的域</p><pre><code>$redis-&gt;hDel(&apos;h&apos;, &apos;key1&apos;);</code></pre><p>hKeys<br>返回名称为key的hash中所有键</p><pre><code>$redis-&gt;hKeys(&apos;h&apos;);</code></pre><p>hVals<br>返回名称为h的hash中所有键对应的value</p><pre><code>$redis-&gt;hVals(&apos;h&apos;)</code></pre><p>hGetAll<br>返回名称为h的hash中所有的键（field）及其对应的value</p><pre><code>$redis-&gt;hGetAll(&apos;h&apos;);</code></pre><p>hExists<br>名称为h的hash中是否存在键名字为a的域</p><pre><code>$redis-&gt;hExists(&apos;h&apos;, &apos;a&apos;);</code></pre><p>hIncrBy<br>将名称为h的hash中x的value增加2</p><pre><code>$redis-&gt;hIncrBy(&apos;h&apos;, &apos;x&apos;, 2);</code></pre><p>hMset<br>向名称为key的hash中批量添加元素</p><pre><code>$redis-&gt;hMset(&apos;user:1&apos;, array(&apos;name&apos; =&gt; &apos;Joe&apos;, &apos;salary&apos; =&gt; 2000));</code></pre><p>hMGet<br>返回名称为h的hash中field1,field2对应的value</p><pre><code>$redis-&gt;hmGet(&apos;h&apos;, array(&apos;field1&apos;, &apos;field2&apos;));</code></pre><h4 id="redis-操作相关"><a href="#redis-操作相关" class="headerlink" title="redis 操作相关"></a>redis 操作相关</h4><p>flushDB<br>清空当前数据库</p><p>flushAll<br>清空所有数据库</p><p>randomKey<br>$key = $redis-&gt;randomKey();<br>随机返回key空间的一个key</p><p>select<br>选择一个数据库<br>move<br>转移一个key到另外一个数据库</p><pre><code>$redis-&gt;select(0); // switch to DB 0$redis-&gt;set(&apos;x&apos;, &apos;42&apos;); // write 42 to x$redis-&gt;move(&apos;x&apos;, 1); // move to DB 1$redis-&gt;select(1); // switch to DB 1$redis-&gt;get(&apos;x&apos;); // will return 42</code></pre><p>rename, renameKey<br>给key重命名</p><pre><code>$redis-&gt;set(&apos;x&apos;, &apos;42&apos;);$redis-&gt;rename(&apos;x&apos;, &apos;y&apos;);$redis-&gt;get(&apos;y&apos;); // → 42$redis-&gt;get(&apos;x&apos;); // → `FALSE`</code></pre><p>renameNx<br>与remane类似，但是，如果重新命名的名字已经存在，不会替换成功</p><p>setTimeout, expire<br>设定一个key的活动时间（s）</p><pre><code>$redis-&gt;setTimeout(&apos;x&apos;, 3);</code></pre><p>expireAt<br>key存活到一个unix时间戳时间</p><pre><code>$redis-&gt;expireAt(&apos;x&apos;, time() + 3);</code></pre><p>keys, getKeys<br>返回满足给定pattern的所有key</p><pre><code>$keyWithUserPrefix = $redis-&gt;keys(&apos;user*&apos;);</code></pre><p>dbSize<br>查看现在数据库有多少key</p><pre><code>$count = $redis-&gt;dbSize();</code></pre><p>auth<br>密码认证</p><pre><code>$redis-&gt;auth(&apos;foobared&apos;);</code></pre><p>bgrewriteaof<br>使用aof来进行数据库持久化</p><pre><code>$redis-&gt;bgrewriteaof();</code></pre><p>slaveof<br>选择从服务器</p><pre><code>$redis-&gt;slaveof(&apos;10.0.1.7&apos;, 6379);</code></pre><p>save<br>将数据同步保存到磁盘</p><p>bgsave<br>将数据异步保存到磁盘</p><p>lastSave<br>返回上次成功将数据保存到磁盘的Unix时戳</p><p>info<br>返回redis的版本信息等详情</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHP使用redis拓展&quot;&gt;&lt;a href=&quot;#PHP使用redis拓展&quot; class=&quot;headerlink&quot; title=&quot;PHP使用redis拓展&quot;&gt;&lt;/a&gt;PHP使用redis拓展&lt;/h1&gt;&lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class
      
    
    </summary>
    
      <category term="技术" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="后端" scheme="https://zx19951110.github.io/ZX.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>NGINX的常用配置</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2017/04/16/NGINX%E7%9A%84%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2017/04/16/NGINX的常用配置/</id>
    <published>2017-04-16T03:49:11.000Z</published>
    <updated>2017-10-14T09:06:34.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx-常见应用技术指南"><a href="#Nginx-常见应用技术指南" class="headerlink" title="Nginx 常见应用技术指南"></a>Nginx 常见应用技术指南</h1><h2 id="正则表达式匹配："><a href="#正则表达式匹配：" class="headerlink" title="正则表达式匹配："></a>正则表达式匹配：</h2><ul><li>* ~ 为区分大小写匹配</li><li>* ~* 为不区分大小写匹配</li><li>* !~和!~*分别为区分大小写不匹配及不区分大小写不匹配</li><li><p>*^~ 如果把这个前缀用于一个常规字符串,那么告诉nginx 如果路径匹配那么不测试正则表达式。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>location = / { # 只匹配 / 查询。}location / { # 匹配任何查询，因为所有请求都已 / 开头。但是正则表达式规则和长的块规则将被优先和查询匹配。}location ^~ /images/ { # 匹配任何已 /images/ 开头的任何查询并且停止搜索。任何正则表达式将不会被测试。}location ~*.(gif|jpg|jpeg)$ { # 匹配任何已 gif、jpg 或 jpeg 结尾的请求。}location ~*.(gif|jpg|swf)$ {  valid_referers none blocked start.igrow.cn sta.igrow.cn;  if ($invalid_referer) {  #防盗链  rewrite ^/ http://$host/logo.png;  }}</code></pre></li></ul><h2 id="文件目录匹配："><a href="#文件目录匹配：" class="headerlink" title="文件目录匹配："></a>文件目录匹配：</h2><ul><li>* -f和!-f用来判断是否存在文件</li><li>* -d和!-d用来判断是否存在目录</li><li>* -e和!-e用来判断是否存在文件或目录</li><li>* -x和!-x用来判断文件是否可执行<h2 id="flag标记"><a href="#flag标记" class="headerlink" title="flag标记:"></a>flag标记:</h2></li><li>* last 相当于Apache里的[L]标记，表示完成rewrite</li><li>* break 终止匹配, 不再匹配后面的规则</li><li>* redirect 返回302临时重定向 地址栏会显示跳转后的地址</li><li>* permanent 返回301永久重定向 地址栏会显示跳转后的地址<h2 id="一些可用的全局变量，可以用做条件判断-待补全"><a href="#一些可用的全局变量，可以用做条件判断-待补全" class="headerlink" title="一些可用的全局变量，可以用做条件判断(待补全):"></a>一些可用的全局变量，可以用做条件判断(待补全):</h2></li><li><p>$args</p></li><li><p>$content_length</p></li><li><p>$content_type</p></li><li><p>$document_root</p></li><li><p>$document_uri</p></li><li><p>$host</p></li><li><p>$http_user_agent</p></li><li><p>$http_cookie</p></li><li><p>$limit_rate</p></li><li><p>$request_body_file</p></li><li><p>$request_method</p></li><li><p>$remote_addr</p></li><li><p>$remote_port</p></li><li><p>$remote_user</p></li><li><p>$request_filename</p></li><li><p>$request_uri</p></li><li><p>$query_string</p></li><li><p>$scheme</p></li><li><p>$server_protocol</p></li><li><p>$server_addr</p></li><li><p>$server_name</p></li><li><p>$server_port</p></li><li><p>$uri</p><h3 id="结合QeePHP的例子"><a href="#结合QeePHP的例子" class="headerlink" title="结合QeePHP的例子:"></a>结合QeePHP的例子:</h3><p>  if (!-d $request_filename) {</p><p>  rewrite ^/([a-z-A-Z]+)/([a-z-A-Z]+)/?(.*)$ /index.php?namespace=user&amp;controller=$1&amp;action=$2&amp;$3 last;</p><p>  rewrite ^/([a-z-A-Z]+)/?$ /index.php?namespace=user&amp;controller=$1 last;</p><p>  break;</p><h3 id="多目录转成参数"><a href="#多目录转成参数" class="headerlink" title="多目录转成参数"></a>多目录转成参数</h3></li></ul><p>abc.domian.com/sort/2 =&gt; abc.domian.com/index.PHP?act=sort&amp;name=abc&amp;id=2</p><pre><code>if ($host ~* (.*)/.domain/.com) {set $sub_name $1;   rewrite ^/sort//(/d+)//?$ /index.php?act=sort&amp;cid=$sub_name&amp;id=$1 last;}</code></pre><h3 id="目录对换"><a href="#目录对换" class="headerlink" title="目录对换"></a>目录对换</h3><p>/123456/xxxx -&gt; /xxxx?id=123456</p><pre><code>rewrite ^/(/d+)/(.+)/ /$2?id=$1 last;</code></pre><p>例如下面设定nginx在用户使用ie的使用重定向到/nginx-ie目录下：</p><pre><code>if ($http_user_agent ~ MSIE) {rewrite ^(.*)$ /nginx-ie/$1 break;}</code></pre><h3 id="目录自动加“-”"><a href="#目录自动加“-”" class="headerlink" title="目录自动加“/”"></a>目录自动加“/”</h3><pre><code>if (-d $request_filename){rewrite ^/(.*)([^/])$ http://$host/$1$2/ permanent;}</code></pre><h3 id="禁止htaccess"><a href="#禁止htaccess" class="headerlink" title="禁止htaccess"></a>禁止htaccess</h3><pre><code>ocation ~//.ht {         deny all;     }</code></pre><h3 id="禁止多个目录"><a href="#禁止多个目录" class="headerlink" title="禁止多个目录"></a>禁止多个目录</h3><pre><code>location ~ ^/(cron|templates)/ {    deny all;    break;}</code></pre><h3 id="禁止以-data开头的文件"><a href="#禁止以-data开头的文件" class="headerlink" title="禁止以/data开头的文件"></a>禁止以/data开头的文件</h3><p>可以禁止/data/下多级目录下.log.txt等请求;</p><pre><code>location ~ ^/data {         deny all;     }</code></pre><h3 id="禁止单个文件"><a href="#禁止单个文件" class="headerlink" title="禁止单个文件"></a>禁止单个文件</h3><pre><code>location ~ /data/sql/data.sql {         deny all;     }</code></pre><h3 id="给favicon-ico和robots-txt设置过期时间"><a href="#给favicon-ico和robots-txt设置过期时间" class="headerlink" title="给favicon.ico和robots.txt设置过期时间:"></a>给favicon.ico和robots.txt设置过期时间:</h3><p>这里为favicon.ico为99天,robots.txt为7天并不记录404错误日志</p><pre><code>location ~(favicon.ico) {log_not_found off;expires 99d;break;}location ~(robots.txt) {log_not_found off;expires 7d;break;}</code></pre><h3 id="设定某个文件的过期时间-这里为600秒，并不记录访问日志"><a href="#设定某个文件的过期时间-这里为600秒，并不记录访问日志" class="headerlink" title="设定某个文件的过期时间;这里为600秒，并不记录访问日志"></a>设定某个文件的过期时间;这里为600秒，并不记录访问日志</h3><pre><code>location ^~ /html/scripts/loadhead_1.js {access_log   off;root /opt/lampp/htdocs/web;expires 600;break;}</code></pre><h3 id="文件反盗链并设置过期时间"><a href="#文件反盗链并设置过期时间" class="headerlink" title="文件反盗链并设置过期时间"></a>文件反盗链并设置过期时间</h3><p>这里的return 412 为自定义的http状态码，默认为403，方便找出正确的盗链的请求<br>“rewrite ^/ <a href="http://leech.c1gstudio.com/leech.gif;”显示一张防盗链图片" target="_blank" rel="external">http://leech.c1gstudio.com/leech.gif;”显示一张防盗链图片</a><br>“access_log off;”不记录访问日志，减轻压力<br>“expires 3d”所有文件3天的浏览器缓存</p><pre><code>location ~* ^.+/.(jpg|jpeg|gif|png|swf|rar|zip|css|js)$ {valid_referers none blocked *.c1gstudio.com *.c1gstudio.net localhost 208.97.167.194;if ($invalid_referer) {    rewrite ^/ http://leech.c1gstudio.com/leech.gif;    return 412;    break;}    access_log   off;    root /opt/lampp/htdocs/web;expires 3d;break;     }</code></pre><h3 id="只充许固定ip访问网站，并加上密码"><a href="#只充许固定ip访问网站，并加上密码" class="headerlink" title="只充许固定ip访问网站，并加上密码"></a>只充许固定ip访问网站，并加上密码</h3><pre><code>root  /opt/htdocs/www;allow   208.97.167.194;allow   222.33.1.2;allow   231.152.49.4;deny    all;auth_basic &quot;C1G_ADMIN&quot;;auth_basic_user_file htpasswd;</code></pre><h3 id="将多级目录下的文件转成一个文件，增强seo效果"><a href="#将多级目录下的文件转成一个文件，增强seo效果" class="headerlink" title="将多级目录下的文件转成一个文件，增强seo效果"></a>将多级目录下的文件转成一个文件，增强seo效果</h3><p>/job-123-456-789.html 指向/job/123/456/789.html</p><pre><code>rewrite ^/job-([0-9]+)-([0-9]+)-([0-9]+)/.html$ /job/$1/$2/jobshow_$3.html last;</code></pre><h3 id="将根目录下某个文件夹指向2级目录"><a href="#将根目录下某个文件夹指向2级目录" class="headerlink" title="将根目录下某个文件夹指向2级目录"></a>将根目录下某个文件夹指向2级目录</h3><p>如/shanghaijob/ 指向 /area/shanghai/<br>如果你将last改成permanent，那么浏览器地址栏显是/location/shanghai/</p><pre><code>rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2 last;上面例子有个问题是访问/shanghai 时将不会匹配ewrite ^/([0-9a-z]+)job$ /area/$1/ last;rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2 last;这样/shanghai 也可以访问了，但页面中的相对链接无法使用，如./list_1.html真实地址是/area/shanghia/list_1.html会变成/list_1.html,导至无法访问。那我加上自动跳转也是不行咯(-d $request_filename)它有个条件是必需为真实目录，而我的rewrite不是的，所以没有效果if (-d $request_filename){rewrite ^/(.*)([^/])$ http://$host/$1$2/ permanent;}知道原因后就好办了，让我手动跳转吧rewrite ^/([0-9a-z]+)job$ /$1job/ permanent;rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2 last;文件和目录不存在的时候重定向：if (!-e $request_filename) {proxy_pass http://127.0.0.1;}</code></pre><h3 id="域名跳转"><a href="#域名跳转" class="headerlink" title="域名跳转:"></a>域名跳转:</h3><pre><code>server     {             listen       80;             server_name  jump.c1gstudio.com;             index index.html index.htm index.php;             root  /opt/lampp/htdocs/www;             rewrite ^/ http://www.c1gstudio.com/;             access_log  off;     }</code></pre><h3 id="多域名转向"><a href="#多域名转向" class="headerlink" title="多域名转向:"></a>多域名转向:</h3><pre><code>server_name  www.c1gstudio.com www.c1gstudio.net;             index index.html index.htm index.php;             root  /opt/lampp/htdocs;if ($host ~ &quot;c1gstudio/.net&quot;) {rewrite ^(.*) http://www.c1gstudio.com$1 permanent;}</code></pre><h3 id="三级域名跳转"><a href="#三级域名跳转" class="headerlink" title="三级域名跳转"></a>三级域名跳转</h3><pre><code>if ($http_host ~* &quot;^(.*)/.i/.c1gstudio/.com$&quot;) {rewrite ^(.*) http://top.yingjiesheng.com$1;break;}</code></pre><h3 id="域名镜像"><a href="#域名镜像" class="headerlink" title="域名镜像"></a>域名镜像</h3><pre><code>server     {             listen       80;             server_name  mirror.c1gstudio.com;             index index.html index.htm index.php;             root  /opt/lampp/htdocs/www;             rewrite ^/(.*) http://www.c1gstudio.com/$1 last;             access_log  off;     }</code></pre><h3 id="某个子目录作镜向"><a href="#某个子目录作镜向" class="headerlink" title="某个子目录作镜向"></a>某个子目录作镜向</h3><pre><code>location ^~ /zhaopinhui {  rewrite ^.+ http://zph.c1gstudio.com/ last;  break;     }</code></pre><h3 id="jspace-rewrite"><a href="#jspace-rewrite" class="headerlink" title="jspace rewrite"></a>jspace rewrite</h3><pre><code>location ~ .*/.php?$             {                  #fastcgi_pass  unix:/tmp/php-cgi.sock;                  fastcgi_pass  127.0.0.1:9000;                  fastcgi_index index.php;                  include fcgi.conf;                  }</code></pre><h3 id="头像-rewrite-优化"><a href="#头像-rewrite-优化" class="headerlink" title="头像 rewrite 优化"></a>头像 rewrite 优化</h3><pre><code>location ^~ /ucenter {     location ~ .*/.php?$     {  #fastcgi_pass  unix:/tmp/php-cgi.sock;  fastcgi_pass  127.0.0.1:9000;  fastcgi_index index.php;  include fcgi.conf;          }     location /ucenter/data/avatar {log_not_found off;access_log   off;location ~ /(.*)_big/.jpg$ {    error_page 404 /ucenter/images/noavatar_big.gif;}location ~ /(.*)_middle/.jpg$ {    error_page 404 /ucenter/images/noavatar_middle.gif;}location ~ /(.*)_small/.jpg$ {    error_page 404 /ucenter/images/noavatar_small.gif;}expires 300;break;     }                       }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx-常见应用技术指南&quot;&gt;&lt;a href=&quot;#Nginx-常见应用技术指南&quot; class=&quot;headerlink&quot; title=&quot;Nginx 常见应用技术指南&quot;&gt;&lt;/a&gt;Nginx 常见应用技术指南&lt;/h1&gt;&lt;h2 id=&quot;正则表达式匹配：&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="技术" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="后端" scheme="https://zx19951110.github.io/ZX.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>windows下配置nginx+mysql+php</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2017/03/25/windows%E4%B8%8B%E9%85%8D%E7%BD%AEnginx-mysql-php/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2017/03/25/windows下配置nginx-mysql-php/</id>
    <published>2017-03-25T05:32:18.000Z</published>
    <updated>2017-11-20T09:06:25.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般来讲很多开发工作并不是在linux中用vim硬怼，很多人用windows编程然后通过git托管，那么我们可以在windows下面安装nginx和php+Mysql来调试我们的程序</p><h2 id="nginx的安装："><a href="#nginx的安装：" class="headerlink" title="nginx的安装："></a>nginx的安装：</h2><p>方法类似linux下安装nginx，在官网上下载ngxin的windows版，解压然后修改conf/nginx.conf，主要修改如下：</p><pre><code>server {        listen       80;#修改监听端口        server_name  localhost;#修改域名        ······        location / {                    root   html;#网站根目录                    index  index.html index.htm index.php;#配置index                }        ······        location ~ \.php$ {                    root           html;#网站根目录                    fastcgi_pass   127.0.0.1:9000;#Nginx以cgi方式用过tcp协议和php交互，也可配置成套接字交互（.sock）方法参考linux下配置                    fastcgi_index  index.php;                    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;#$document_root指的是web根目录，不配置可能会有No input file specified.错误                    include        fastcgi_params;                }</code></pre><p>附上Nginx的常用命令：</p><pre><code>运行start nginx关闭 nginx -s stop    或者    nginx -s quitstop表示立即停止nginx,不保存相关信息quit表示正常退出nginx,并保存相关信息重启(因为改变了配置,需要重启)nginx -s reload</code></pre><p>然后我们访问localhost，会看到nginx的欢迎界面。</p><h2 id="php的安装"><a href="#php的安装" class="headerlink" title="php的安装:"></a>php的安装:</h2><p>php在windows下面安装方式网上一搜一大堆，整理下就是：</p><ul><li><p>直接解压下载好的php包，把解压出来的文件夹重命名成php5。进入文件夹修改php.ini-recommended文件为php.ini，编辑文件：</p><pre><code>extension_dir = &quot;./ext&quot;</code></pre><p>  更改为</p><pre><code>extension_dir = &quot;D:/wnmp/php5/ext&quot;</code></pre><p>  往下看，再找到</p><pre><code>;extension=php_mysql.dll;extension=php_mysqli.dll</code></pre><p>  前面指定了php的ext路径后，只要把需要的扩展包前面所对应的“;”去掉，就可以了。这里打开php_mysql.dll和php_mysqli.dll，让php支持mysql。</p><p>  到这里，php已经可以支持mysql了。</p><p>  接下来我们来配置php，让php能够与nginx结合。找到</p><pre><code>;cgi.fix_pathinfo=1</code></pre><p>  我们去掉这里的封号。</p><pre><code>cgi.fix_pathinfo=1</code></pre><h5 id="这一步非常重要，这里是php的CGI的设置。"><a href="#这一步非常重要，这里是php的CGI的设置。" class="headerlink" title="这一步非常重要，这里是php的CGI的设置。"></a>这一步非常重要，这里是php的CGI的设置。</h5></li><li><p>输入命令</p><pre><code>php-cgi -b 127.0.0.1:9000 -c $PHP_PATH./php.ini #$PHP_PATH是你php的根目录</code></pre><p>然后利用如下命令：</p><pre><code>netstat -a</code></pre><p>查看9000端口是否已经被php监听，如果是，那么大功告成</p><h3 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h3><p>php文件访问时会有No input file specified.错误，原因是没有配置</p><p>  fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name; #document_root是根目录<br>这个错误类似404</p></li></ul><h2 id="MySQL的安装："><a href="#MySQL的安装：" class="headerlink" title="MySQL的安装："></a>MySQL的安装：</h2><p>由于是在windows下面安装MySQL，操作自然没有在linux下面那么风骚，接下来以MySQL5.7为例，来聊一聊mysql的安装：</p><ul><li><p>首先下载mysql的windows版本，解压后新建my.ini或者修改my-defalut.ini为my.ini，并添加以下配置：</p><pre><code>[mysql]#设置mysql客户端默认字符集default-character-set=utf8 [mysqld]#设置3306端口port = 3306 #设置mysql的安装目录basedir=D:\Programs\mysql-5.7.17-winx64#设置mysql数据库的数据的存放目录datadir=D:\Programs\mysql-5.7.17-winx64\data #坑注意！#允许最大连接数max_connections=200#服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8#创建新表时将使用的默认存储引擎default-storage-engine=INNODB </code></pre></li><li><p>前方高坑预警：如果你以为这么久可以直接启动服务那就真是naive了，5.7版本的mysql没有data文件夹，所以会导致服务打不开并且不报错，这个问题可以用如下命令解决：<br>   cd到mysql的bin文件夹并且以管理员打开cmd运行下面命令：</p><pre><code>mysqld --initialize --user=mysql --console</code></pre><p>   先执行以上命令, 生成库. 注意有个临时密码, 要记下来.<br>   然后启动服务：</p><pre><code>net start mysql</code></pre><p>   然后再命令行:</p><pre><code>mysql -uroot -p</code></pre><p>   输入密码（生成表命令最后一行）进入mysql：</p><pre><code>set password = password(&apos;root&apos;) #设置密码为root</code></pre><p>   必须修改否则无法使用mysql</p><h3 id="踩过的坑-1"><a href="#踩过的坑-1" class="headerlink" title="踩过的坑"></a>踩过的坑</h3><p>妈个鸡mysql5.7居然没有data文件夹，而且启动服务不报错，找了好久才找到问题，具体的报错可以用下面命令查看：</p><pre><code>mysqld -nt -install #安装并打印日志</code></pre></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>没啥好总结的，在windows上面要是这些都不会装和咸鱼有什么区别。<br>在linux上面安装和在windows上面大同小异，值得一提的是虽然可以用tcp方式监听9000端口使nginx和php交互，但是利用套接字文件更快（.sock），linux上面启动php需要启动php-fpm.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一般来讲很多开发工作并不是在linux中用vim硬怼，很多人用windows编程然后通过git托管，那么我们可以在windows下面安装ng
      
    
    </summary>
    
      <category term="技术" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="后端" scheme="https://zx19951110.github.io/ZX.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>PHP使用Mongo</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2017/03/20/PHP%E4%BD%BF%E7%94%A8Mongo/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2017/03/20/PHP使用Mongo/</id>
    <published>2017-03-20T12:40:34.000Z</published>
    <updated>2017-11-16T10:29:33.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mongo介绍"><a href="#Mongo介绍" class="headerlink" title="Mongo介绍"></a>Mongo介绍</h2><p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。作为非关系型数据库，Mongo有一定趋势成为主流noSQL的DB</p><h2 id="php连接mongo具体操作"><a href="#php连接mongo具体操作" class="headerlink" title="php连接mongo具体操作"></a>php连接mongo具体操作</h2><h3 id="mongo的连接"><a href="#mongo的连接" class="headerlink" title="mongo的连接"></a>mongo的连接</h3><pre><code>$conn = new MongoClient(&quot;mongodb://127.0.0.1:8550&quot;);//创建一个mongo的连接//$conn=new Mongo(); #连接本地主机,默认端口.//$conn=new Mongo(“172.21.15.69″); #连接远程主机//$conn=new Mongo(“xiaocai.loc:10086″); #连接指定端口远程主机//$conn=new Mongo(“xiaocai.loc”,array(“replicaSet”=&gt;true)); #负载均衡//$conn=new Mongo(“xiaocai.loc”,array(“persist”=&gt;”t”)); #持久连接//$conn=new Mongo(“mongodb://sa:123@localhost”); #带用户名密码//$conn=new Mongo(“mongodb://localhost:27017,localhost:27018″); #连接多个服务器//$conn=new Mongo(“mongodb:///tmp/mongo-27017.sock”); #域套接字//$conn=new Mongo(“mongodb://admin_miss:miss@localhost:27017/test”,array(‘persist’=&gt;’p&apos;,”replicaSet”=&gt;true)); #完整连接</code></pre><h3 id="选择数据库与表"><a href="#选择数据库与表" class="headerlink" title="选择数据库与表"></a>选择数据库与表</h3><pre><code>$db=$conn-&gt;mydb; #选择mydb数据库//$db=$conn-&gt;selectDB(“mydb”); #第二种写法$collection=$db-&gt;column; #选择集合(选择’表’)//$collection=$db-&gt;selectCollection(‘column’); #第二种写法//$collection=$conn-&gt;mydb-&gt;column; #更简洁的写法(常用且推荐)</code></pre><h3 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h3><pre><code>//**向集合中插入数据,返回bool判断是否插入成功. **/$array=array(‘column_name’=&gt;’col’.rand(100,999),’column_exp’=&gt;’xiaocai’);$result=$collection-&gt;insert($array); #简单插入echo “新记录ID:”.$array[&apos;_id&apos;]; #MongoDB会返回一个记录标识var_dump($result); #返回:bool(true)//**向集合中安全插入数据,返回插入状态(数组). **/$array=array(‘column_name’=&gt;’col’.rand(100,999),’column_exp’=&gt;’xiaocai2′);$result=$collection-&gt;insert($array,true); #用于等待MongoDB完成操作,以便确定是否成功.(当有大量记录插入时使用该参数会比较有用)echo “新记录ID:”.$array[&apos;_id&apos;]; #MongoDB会返回一个记录标识var_dump($result); #返回:array(3) { [&quot;err&quot;]=&gt; NULL [&quot;n&quot;]=&gt; int(0) [&quot;ok&quot;]=&gt; float(1) }//**完整的写法 **/#insert($array,array(‘safe’=&gt;false,’fsync’=&gt;false,’timeout’=&gt;10000))/** ** 完整格式:insert ( array $a [, array $options = array() ] )*    insert(array(),array(‘safe’=&gt;false,’fsync’=&gt;false,’timeout’=&gt;10000))*       参数:safe:默认false,是否安全写入*   fsync:默认false,是否强制插入到同步到磁盘*     timeout:超时时间(毫秒)** 插入结果:{ “_id” : ObjectId(“4d63552ad549a02c01000009″), “column_name” : “col770″, “column_exp” : “xiaocai” }*    ’_id’为主键字段,在插入是MongoDB自动添加.**    注意:1.以下两次插入的为同一条记录(相同的_id),因为它们的值相同。*         $collection-&gt;insert(array(‘column_name’=&gt;’xiaocai’));*         $collection-&gt;insert(array(‘column_name’=&gt;’xiaocai’));*     避免* $collection-&gt;insert(array(‘column_name’=&gt;’xiaocai’),true);* try {*      $collection-&gt;insert(array(‘column_name’=&gt;’xiaocai’),true);* }catch(MongoCursorException $e){*      echo “Can’t save the same person twice!\n”;* }</code></pre><h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><pre><code>$where=array(‘column_name’=&gt;’col123′);$newdata=array(‘column_exp’=&gt;’GGGGGGG’,&apos;column_fid’=&gt;444);$result=$collection-&gt;update($where,array(‘$set’=&gt;$newdata)); #$set:让某节点等于给定值,类似的还有$pull $pullAll $pop $inc,在后面慢慢说明用法/** 结果:* 原数据* {“_id”:ObjectId(“4d635ba2d549a02801000003″),”column_name”:”col123″,”column_exp”:”xiaocai”}* 被替换成了* {“_id”:ObjectId(“4d635ba2d549a02801000003″),”column_name”:”col123″,”column_exp”:”GGGGGGG”,”column_fid”:444}*///** 替换更新 **/$where=array(‘column_name’=&gt;’col709′);$newdata=array(‘column_exp’=&gt;’HHHHHHHHH’,&apos;column_fid’=&gt;123);$result=$collection-&gt;update($where,$newdata);/** 结果:* 原数据* {“_id”:ObjectId(“4d635ba2d549a02801000003″),”column_name”:”col709″,”column_exp”:”xiaocai”}* 被替换成了* {“_id”:ObjectId(“4d635ba2d549a02801000003″),”column_exp”:”HHHHHHHHH”,”column_fid”:123}*///** 批量更新 **/$where=array(‘column_name’=&gt;’col’);$newdata=array(‘column_exp’=&gt;’multiple’,’91u’=&gt;684435);$result=$collection-&gt;update($where,array(‘$set’=&gt;$newdata),array(‘multiple’=&gt;true));/*** 所有’column_name’=&apos;col’都被修改*///** 自动累加 **/$where=array(’91u’=&gt;684435);$newdata=array(‘column_exp’=&gt;’edit’);$result=$collection-&gt;update($where,array(‘$set’=&gt;$newdata,’$inc’=&gt;array(’91u’=&gt;-5)));/*** 更新91u=684435的数据,并且91u自减5*//** 删除节点 **/$where=array(‘column_name’=&gt;’col685′);$result=$collection-&gt;update($where,array(‘$unset’=&gt;’column_exp’));/*** 删除节点column_exp*//** ** 完整格式:update(array $criteria, array $newobj [, array $options = array()  ] )*       注意:1.注意区分替换更新与修改更新*    2.注意区分数据类型如 array(’91u’=&gt;’684435′)与array(’91u’=&gt;684435)* 详细资料:http://www.mongodb.org/display/DOCS/Updating#Updating-%24bit* **/</code></pre><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><pre><code>/** 清空数据库 **/$collection-&gt;remove(array(‘column_name’=&gt;’col399′));//$collection-&gt;remove(); #清空集合/** 删除指定MongoId **/$id = new MongoId(“4d638ea1d549a02801000011″);$collection-&gt;remove(array(‘_id’=&gt;(object)$id));/** **  使用下面的方法来匹配{“_id”:ObjectId(“4d638ea1d549a02801000011″)},查询、更新也一样*  $id = new MongoId(“4d638ea1d549a02801000011″);*  array(‘_id’=&gt;(object)$id)* **/</code></pre><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><pre><code>/** 查询文档中的记录数 **/echo ‘count:’.$collection-&gt;count().”&lt;br&gt;”; #全部echo ‘count:’.$collection-&gt;count(array(‘type’=&gt;’user’)).”&lt;br&gt;”; #可以加上条件echo ‘count:’.$collection-&gt;count(array(‘age’=&gt;array(‘$gt’=&gt;50,’$lte’=&gt;74))).”&lt;br&gt;”; #大于50小于等于74echo ‘count:’.$collection-&gt;find()-&gt;limit(5)-&gt;skip(0)-&gt;count(true).”&lt;br&gt;”; #获得实际返回的结果数/*** 注:$gt为大于、$gte为大于等于、$lt为小于、$lte为小于等于、$ne为不等于、$exists不存在*//** 集合中所有文档 **/$cursor = $collection-&gt;find()-&gt;snapshot();foreach ($cursor as $id =&gt; $value) {echo “$id: “; var_dump($value); echo “&lt;br&gt;”;}/*** 注意:* 在我们做了find()操作，获得$cursor游标之后，这个游标还是动态的.* 换句话说,在我find()之后,到我的游标循环完成这段时间,如果再有符合条件的记录被插入到collection,那么这些记录也会被$cursor 获得.* 如果你想在获得$cursor之后的结果集不变化,需要这样做：* $cursor = $collection-&gt;find();* $cursor-&gt;snapshot();* 详见http://www.bumao.com/index.php/2010/08/mongo_php_cursor.html*//** 查询一条数据 **/$cursor = $collection-&gt;findOne();/***  注意:findOne()获得结果集后不能使用snapshot(),fields()等函数;*//** age,type 列不显示 **/$cursor = $collection-&gt;find()-&gt;fields(array(“age”=&gt;false,”type”=&gt;false));/** 只显示user 列 **/$cursor = $collection-&gt;find()-&gt;fields(array(“user”=&gt;true));/*** 我这样写会出错:$cursor-&gt;fields(array(“age”=&gt;true,”type”=&gt;false));*//** (存在type,age节点) and age!=0 and age&lt;50 **/$where=array(‘type’=&gt;array(‘$exists’=&gt;true),’age’=&gt;array(‘$ne’=&gt;0,’$lt’=&gt;50,’$exists’=&gt;true));$cursor = $collection-&gt;find($where);/** 分页获取结果集  **/$cursor = $collection-&gt;find()-&gt;limit(5)-&gt;skip(0);/** 排序  **/$cursor = $collection-&gt;find()-&gt;sort(array(‘age’=&gt;-1,’type’=&gt;1)); ##1表示降序 -1表示升序,参数的先后影响排序顺序/** 索引  **/$collection-&gt;ensureIndex(array(‘age’ =&gt; 1,’type’=&gt;-1)); #1表示降序 -1表示升序$collection-&gt;ensureIndex(array(‘age’ =&gt; 1,’type’=&gt;-1),array(‘background’=&gt;true)); #索引的创建放在后台运行(默认是同步运行)$collection-&gt;ensureIndex(array(‘age’ =&gt; 1,’type’=&gt;-1),array(‘unique’=&gt;true)); #该索引是唯一的/*** ensureIndex (array(),array(‘name’=&gt;’索引名称’,&apos;background’=true,’unique’=true))* 详见:http://www.php.net/manual/en/mongocollection.ensureindex.php*//** 取得查询结果 **/$cursor = $collection-&gt;find();$array=array();foreach ($cursor as $id =&gt; $value) {$array[]=$value;}</code></pre><h3 id="文档聚类"><a href="#文档聚类" class="headerlink" title="文档聚类"></a>文档聚类</h3><pre><code>$conn-&gt;close(); #关闭连接/*关系型数据库与MongoDB数据存储的区别MySql数据结构:CREATE TABLE IF NOT EXISTS `column`(`column_id` int(16)  NOT NULL  auto_increment  COMMENT ‘主键’,`column_name` varchar(32) NOT NULL COMMENT ‘栏目名称’,PRIMARY KEY  (`column_id`));CREATE TABLE IF NOT EXISTS `article`(`article_id`  int(16)  NOT NULL  auto_increment  COMMENT ‘主键’,`article_caption` varchar(15) NOT NULL COMMENT ‘标题’,PRIMARY KEY(`article_id`));CREATE TABLE IF NOT EXISTS `article_body`(`article_id` int(16) NOT NULL COMMENT ‘article.article_id’,`body` text COMMENT ‘正文’);MongoDB数据结构:$data=array(‘column_name’ =&gt;’default’,‘article’ =&gt;array(‘article_caption’ =&gt; ‘xiaocai’,‘body’   =&gt; ‘xxxxxxxxxx…’));$inc如果记录的该节点存在，让该节点的数值加N；如果该节点不存在，让该节点值等于N设结构记录结构为 array(’a’=&gt;1,’b’=&gt;’t’),想让a加5，那么：$coll-&gt;update(array(’b’=&gt;’t’),array(’$inc’=&gt;array(’a’=&gt;5)),)$set让某节点等于给定值设结构记录结构为 array(’a’=&gt;1,’b’=&gt;’t’),b为加f，那么：$coll-&gt;update(array(’a’=&gt;1),array(’$set’=&gt;array(’b’=&gt;’f’)),)$unset删除某节点设记录结构为 array(’a’=&gt;1,’b’=&gt;’t’)，想删除b节点，那么：$coll-&gt;update(array(’a’=&gt;1),array(’$unset’=&gt;’b’),)$push如果对应节点是个数组，就附加一个新的值上去；不存在，就创建这个数组，并附加一个值在这个数组上；如果该节点不是数组，返回错误。设记录结构为array(’a’=&gt;array(0=&gt;’haha’),’b’=&amp; gt;1)，想附加新数据到节点a，那么：$coll-&gt;update(array(’b’=&gt;1),array(’$push’=&gt;array(’a’=&gt;’wow’)),)这样，该记录就会成为：array(’a’=&gt;array(0=&gt;’haha’,1=&gt;’wow’),’b’=&gt;1)$pushAll与$push类似，只是会一次附加多个数值到某节点$addToSet如果该阶段的数组中没有某值，就添加之设记录结构为array(’a’=&gt;array(0=&amp; gt;’haha’),’b’=&gt;1)，如果想附加新的数据到该节点a，那么：$coll-&gt;update(array(’b’=&gt;1),array(’$addToSet’=&gt;array(’a’=&gt;’wow’)),)如果在a节点中已经有了wow,那么就不会再添加新的，如果没有，就会为该节点添加新的item——wow。$pop设该记录为array(’a’=&gt;array(0=&gt;’haha’,1=&amp; gt;’wow’),’b’=&gt;1)删除某数组节点的最后一个元素:$coll-&gt;update(array(’b’=&gt;1),array(’$pop=&gt;array(’a’=&gt;1)),)删除某数组阶段的第一个元素$coll-&gt;update(array(’b’=&gt;1),array(’$pop=&gt;array(’a’=&gt;-1)),)$pull如果该节点是个数组，那么删除其值为value的子项，如果不是数组，会返回一个错误。设该记录为 array(’a’=&gt;array(0=&gt;’haha’,1=&gt;’wow’),’b’=&gt;1)，想要删除a中value为 haha的子项：$coll-&gt;update(array(’b’=&gt;1),array(’$pull=&gt;array(’a’=&gt;’haha’)),)结果为： array(’a’=&gt;array(0=&gt;’wow’),’b’=&gt;1)$pullAll与$pull类似，只是可以删除一组符合条件的记录。*/?&gt;</code></pre><h5 id="本篇文章太长估计没人会看完，当作字典去查吧233333"><a href="#本篇文章太长估计没人会看完，当作字典去查吧233333" class="headerlink" title="本篇文章太长估计没人会看完，当作字典去查吧233333"></a>本篇文章太长估计没人会看完，当作字典去查吧233333</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Mongo介绍&quot;&gt;&lt;a href=&quot;#Mongo介绍&quot; class=&quot;headerlink&quot; title=&quot;Mongo介绍&quot;&gt;&lt;/a&gt;Mongo介绍&lt;/h2&gt;&lt;p&gt;MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数
      
    
    </summary>
    
      <category term="技术" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="后端" scheme="https://zx19951110.github.io/ZX.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Nginx在linux下的安装与配置</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2017/03/20/Nginx%E5%9C%A8linux%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2017/03/20/Nginx在linux下的安装与配置/</id>
    <published>2017-03-20T12:40:18.000Z</published>
    <updated>2017-10-13T22:41:48.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h2><p>Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。LNMP的开发模式渐渐成为主流。</p><h2 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h2><p>从nginx官网上下载linux版本的Nginx</p><pre><code>wget http://nginx.org/download/nginx-1.5.9.tar.gz</code></pre><p>解压后进入目录</p><pre><code>./configure --user=www --group=www --prefix=安装目录</code></pre><p>生成编译文件</p><pre><code>make</code></pre><p>安装</p><pre><code>make install</code></pre><p>修改安装目录下的conf/Nginx.conf，将监听端口改成没有被占用的端口</p><pre><code>sbin/nginx </code></pre><p>启动服务就可以啦，可以看一下是否启动成功 </p><pre><code>sbin/nginx -t</code></pre><h2 id="Nginx的配置"><a href="#Nginx的配置" class="headerlink" title="Nginx的配置"></a>Nginx的配置</h2><h4 id="http反向代理配置"><a href="#http反向代理配置" class="headerlink" title="http反向代理配置"></a>http反向代理配置</h4><p>修改nginx.conf文件</p><pre><code>#运行用户#user somebody;#启动进程,通常设置成和cpu的数量相等worker_processes  1;#全局错误日志error_log  D:/Tools/nginx-1.10.1/logs/error.log;error_log  D:/Tools/nginx-1.10.1/logs/notice.log  notice;error_log  D:/Tools/nginx-1.10.1/logs/info.log  info;#PID文件，记录当前启动的nginx的进程IDpid        D:/Tools/nginx-1.10.1/logs/nginx.pid;#工作模式及连接数上限events {    worker_connections 1024;    #单个后台worker process进程的最大并发链接数}#设定http服务器，利用它的反向代理功能提供负载均衡支持http {    #设定mime类型(邮件支持类型),类型由mime.types文件定义    include       D:/Tools/nginx-1.10.1/conf/mime.types;    default_type  application/octet-stream;    #设定日志    log_format  main  &apos;[$remote_addr] - [$remote_user] [$time_local] &quot;$request&quot; &apos;                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;    access_log    D:/Tools/nginx-1.10.1/logs/access.log main;    rewrite_log     on;    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用，    #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.    sendfile        on;    #tcp_nopush     on;    #连接超时时间    keepalive_timeout  120;    tcp_nodelay        on;    #gzip压缩开关    #gzip  on;    #设定实际的服务器列表     upstream zp_server1{        server 127.0.0.1:8089;    }    #HTTP服务器    server {        #监听80端口，80端口是知名端口号，用于HTTP协议        listen       80;        #定义使用www.xx.com访问        server_name  www.helloworld.com;        #首页        index index.html        #指向webapp的目录        root D:\01_Workspace\Project\github\zp\SpringNotes\spring-security\spring-shiro\src\main\webapp;        #编码格式        charset utf-8;        #代理配置参数        proxy_connect_timeout 180;        proxy_send_timeout 180;        proxy_read_timeout 180;        proxy_set_header Host $host;        proxy_set_header X-Forwarder-For $remote_addr;        #反向代理的路径（和upstream绑定），location 后面设置映射的路径        location / {            proxy_pass http://zp_server1;        }         #静态文件，nginx自己处理        location ~ ^/(images|javascript|js|css|flash|media|static)/ {            root D:\01_Workspace\Project\github\zp\SpringNotes\spring-security\spring-shiro\src\main\webapp\views;            #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。            expires 30d;        }        #设定查看Nginx状态的地址        location /NginxStatus {            stub_status           on;            access_log            on;            auth_basic            &quot;NginxStatus&quot;;            auth_basic_user_file  conf/htpasswd;        }        #禁止访问 .htxxx 文件        location ~ /\.ht {            deny all;        }        #错误处理页面（可选择性配置）        #error_page   404              /404.html;        #error_page   500 502 503 504  /50x.html;        #location = /50x.html {        #    root   html;        #}    }}</code></pre><h3 id="负载均衡配置"><a href="#负载均衡配置" class="headerlink" title="负载均衡配置"></a>负载均衡配置</h3><p>网站在实际运营过程中，多半都是有多台服务器运行着同样的app，这时需要使用负载均衡来分流。<br>假设这样一个应用场景：将应用部署在192.168.1.11:80、192.168.1.12:80、192.168.1.13:80三台linux环境的服务器上。公网IP为192.168.1.11。在公网IP所在的服务器上部署nginx，对所有请求做负载均衡处理。<br>nginx.conf配置如下：<br>    http {</p><pre><code>     #设定mime类型,类型由mime.type文件定义    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    #设定日志格式    access_log    /var/log/nginx/access.log;    #设定负载均衡的服务器列表    upstream load_balance_server {        #weigth参数表示权值，权值越高被分配到的几率越大        server 192.168.1.11:80   weight=5;        server 192.168.1.12:80   weight=1;        server 192.168.1.13:80   weight=6;    }   #HTTP服务器   server {        #侦听80端口        listen       80;        #定义使用www.xx.com访问        server_name  www.helloworld.com;        #对所有请求进行负载均衡请求        location / {            root        /root;                 #定义服务器的默认网站根目录位置            index       index.html index.htm;  #定义首页索引文件的名称            proxy_pass  http://load_balance_server ;#请求转向load_balance_server 定义的服务器列表            #以下是一些反向代理的配置(可选择性配置)            #proxy_redirect off;            proxy_set_header Host $host;            proxy_set_header X-Real-IP $remote_addr;            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP            proxy_set_header X-Forwarded-For $remote_addr;            proxy_connect_timeout 90;          #nginx跟后端服务器连接超时时间(代理连接超时)            proxy_send_timeout 90;             #后端服务器数据回传时间(代理发送超时)            proxy_read_timeout 90;             #连接成功后，后端服务器响应时间(代理接收超时)            proxy_buffer_size 4k;              #设置代理服务器（nginx）保存用户头信息的缓冲区大小            proxy_buffers 4 32k;               #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置            proxy_busy_buffers_size 64k;       #高负荷下缓冲大小（proxy_buffers*2）            proxy_temp_file_write_size 64k;    #设定缓存文件夹大小，大于这个值，将从upstream服务器传            client_max_body_size 10m;          #允许客户端请求的最大单文件字节数            client_body_buffer_size 128k;      #缓冲区代理缓冲用户端请求的最大字节数        }    }}</code></pre><h3 id="多个app配置"><a href="#多个app配置" class="headerlink" title="多个app配置"></a>多个app配置</h3><p>当一个网站功能越来越丰富时，往往需要将一些功能相对独立的模块剥离出来，独立维护。这样的话，通常，会有多个webapp。我们知道，http的默认端口号是80，如果在一台服务器上同时启动这3个webapp应用，都用80端口，肯定是不成的。所以，这三个应用需要分别绑定不同的端口号。那么，问题来了，用户在访问不同webapp，总不会还带着对应的端口号去访问吧。所以，你再次需要用到反向代理来做处理。<br>    http {</p><pre><code>    #此处省略一些基本配置    upstream product_server{        server www.helloworld.com:8081;    }    upstream admin_server{        server www.helloworld.com:8082;    }    upstream finance_server{        server www.helloworld.com:8083;    }    server {        #此处省略一些基本配置        #默认指向product的server        location / {            proxy_pass http://product_server;        }        location /product/{            proxy_pass http://product_server;        }        location /admin/ {            proxy_pass http://admin_server;        }        location /finance/ {            proxy_pass http://finance_server;        }    }}</code></pre><h3 id="https反向代理配置"><a href="#https反向代理配置" class="headerlink" title="https反向代理配置"></a>https反向代理配置</h3><p>一些对安全性要求比较高的站点，可能会使用HTTPS（一种使用ssl通信标准的安全HTTP协议）。<br>这里不科普HTTP协议和SSL标准。但是，使用nginx配置https需要知道几点：<br>HTTPS的固定端口号是443，不同于HTTP的80端口<br>SSL标准需要引入安全证书，所以在nginx.conf中你需要指定证书和它对应的key<br>其他和http反向代理基本一样，只是在Server部分配置有些不同。</p><pre><code>#HTTP服务器server {    #监听443端口。443为知名端口号，主要用于HTTPS协议    listen       443 ssl;    #定义使用www.xx.com访问    server_name  www.helloworld.com;    #ssl证书文件位置(常见证书文件格式为：crt/pem)    ssl_certificate      cert.pem;    #ssl证书key位置    ssl_certificate_key  cert.key;    #ssl配置参数（选择性配置）    ssl_session_cache    shared:SSL:1m;    ssl_session_timeout  5m;    #数字签名，此处使用MD5    ssl_ciphers  HIGH:!aNULL:!MD5;    ssl_prefer_server_ciphers  on;    location / {        root   /root;        index  index.html index.htm;    }}</code></pre><h4 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h4><p>在配置php服务时，需要取消一段注释并且配置php-cgi.sock的路径</p><pre><code>location ~ \.php$ {    root           /home/users/zhanxu/home/Lab;    fastcgi_pass   &apos;unix:/home/users/zhanxu/home/odp/var/php-cgi.sock&apos;;#php-cgi路径没有玩个蛋    #fastcgi_index  index.php;    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;    include        fastcgi.conf;}</code></pre><h5 id="推荐文章："><a href="#推荐文章：" class="headerlink" title="推荐文章："></a>推荐文章：</h5><p><a href="http://www.cnblogs.com/jingmoxukong/p/5945200.html" target="_blank" rel="external">http://www.cnblogs.com/jingmoxukong/p/5945200.html</a> </p><p><a href="http://tool.oschina.net/apidocs/apidoc?api=nginx-zh" target="_blank" rel="external">http://tool.oschina.net/apidocs/apidoc?api=nginx-zh</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Nginx简介&quot;&gt;&lt;a href=&quot;#Nginx简介&quot; class=&quot;headerlink&quot; title=&quot;Nginx简介&quot;&gt;&lt;/a&gt;Nginx简介&lt;/h2&gt;&lt;p&gt;Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/PO
      
    
    </summary>
    
      <category term="技术" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="后端" scheme="https://zx19951110.github.io/ZX.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>PHP中CURL的option参数详解、</title>
    <link href="https://zx19951110.github.io/ZX.github.io/2017/03/19/PHP%E4%B8%ADCURL%E7%9A%84%E9%80%89%E9%A1%B9%E8%AF%A6%E8%A7%A3/"/>
    <id>https://zx19951110.github.io/ZX.github.io/2017/03/19/PHP中CURL的选项详解/</id>
    <published>2017-03-19T09:49:44.000Z</published>
    <updated>2017-10-13T22:42:23.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p>学习了CURL的访问模式，卧槽真的比file_get_content()高到不知道哪里去了，几乎就是一个小型在php内部的浏览器。首先通过curl_init()实例化一个CURL对象，然后通过curl_setopt()函数给这次回话添加一些设置，比如NO_BODY属性之类的等等，最后通过curl_exec($curl_object)进行访问。常用curl的define参数如下：</p><h2 id="参数详情："><a href="#参数详情：" class="headerlink" title="参数详情："></a>参数详情：</h2><p>bool curl_setopt (int ch, string option, mixed value)<br>curl_setopt()函数将为一个CURL会话设置选项。option参数是你想要的设置，value是这个选项给定的值。</p><h3 id="下列选项的值将被作为长整形使用-在option参数中指定-："><a href="#下列选项的值将被作为长整形使用-在option参数中指定-：" class="headerlink" title="下列选项的值将被作为长整形使用(在option参数中指定)："></a>下列选项的值将被作为长整形使用(在option参数中指定)：</h3><ul><li>CURLOPT_INFILESIZE : 当你上传一个文件到远程站点，这个选项告诉PHP你上传文件的大小。</li><li>CURLOPT_VERBOSE : 如果你想CURL报告每一件意外的事情，设置这个选项为一个非零值。</li><li>CURLOPT_HEADER : 如果你想把一个头包含在输出中，设置这个选项为一个非零值。</li><li>CURLOPT_NOPROGRESS: 如果你不会PHP为CURL传输显示一个进程条，设置这个选项为一个非零值。注意：PHP自动设置这个选项为非零值，你应该仅仅为了调试的目的来改变这个选项。</li><li>CURLOPT_NOBODY : 如果你不想在输出中包含body部分，设置这个选项为一个非零值。</li><li>CURLOPT_FAILONERROR : 如果你想让PHP在发生错误(HTTP代码返回大于等于300)时，不显示，设置这个选项为一人非零值。默认行为是返回一个正常页，忽略代码。</li><li>CURLOPT_UPLOAD: 如果你想让PHP为上传做准备，设置这个选项为一个非零值。</li><li>CURLOPT_POST : 如果你想PHP去做一个正规的HTTP POST，设置这个选项为一个非零值。这个POST是普通的 application/x-www-from-urlencoded 类型，多数被HTML表单使用。</li><li>CURLOPT_FTPLISTONLY : 设置这个选项为非零值，PHP将列出FTP的目录名列表。</li><li>CURLOPT_FTPAPPEND : 设置这个选项为一个非零值，PHP将应用远程文件代替覆盖它。</li><li>CURLOPT_NETRC : 设置这个选项为一个非零值，PHP将在你的 ~./netrc 文件中查找你要建立连接的远程站点的用户名及密码。</li><li>CURLOPT_FOLLOWLOCATION : 设置这个选项为一个非零值(象 “Location: “)的头，服务器会把它当做HTTP头的一部分发送(注意这是递归的，PHP将发送形如 “Location: “的头)。</li><li>CURLOPT_PUT : 设置这个选项为一个非零值去用HTTP上传一个文件。要上传这个文件必须设置CURLOPT_INFILE和CURLOPT_INFILESIZE选项.</li><li>CURLOPT_MUTE : 设置这个选项为一个非零值，PHP对于CURL函数将完全沉默。</li><li>CURLOPT_TIMEOUT : 设置一个长整形数，作为最大延续多少秒。</li><li>CURLOPT_LOW_SPEED_LIMIT: 设置一个长整形数，控制传送多少字节。</li><li>CURLOPT_LOW_SPEED_TIME : 设置一个长整形数，控制多少秒传送CURLOPT_LOW_SPEED_LIMIT规定的字节数。</li><li>CURLOPT_RESUME_FROM : 传递一个包含字节偏移地址的长整形参数，(你想转移到的开始表单)。</li><li>CURLOPT_SSLVERSION: 传递一个包含SSL版本的长参数。默认PHP将被它自己努力的确定，在更多的安全中你必须手工设置。</li><li>CURLOPT_TIMECONDITION : 传递一个长参数，指定怎么处理CURLOPT_TIMEVALUE参数。你可以设置这个参数为TIMECOND_IFMODSINCE 或 TIMECOND_ISUNMODSINCE。这仅用于HTTP。</li><li>CURLOPT_TIMEVALUE : 传递一个从1970-1-1开始到现在的秒数。这个时间将被CURLOPT_TIMEVALUE选项作为指定值使用，或被默认TIMECOND_IFMODSINCE使用。<h3 id="下列选项的值将被作为字符串："><a href="#下列选项的值将被作为字符串：" class="headerlink" title="下列选项的值将被作为字符串："></a>下列选项的值将被作为字符串：</h3></li><li>CURLOPT_URL: 这是你想用PHP取回的URL地址。你也可以在用curl_init()函数初始化时设置这个选项。</li><li>CURLOPT_USERPWD : 传递一个形如[username]:[password]风格的字符串,作用PHP去连接。</li><li>CURLOPT_PROXYUSERPWD : 传递一个形如[username]:[password] 格式的字符串去连接HTTP代理。</li><li>CURLOPT_RANGE : 传递一个你想指定的范围。它应该是”X-Y”格式，X或Y是被除外的。HTTP传送同样支持几个间隔，用逗句来分隔(X-Y,N-M)。</li><li>CURLOPT_POSTFIELDS : 传递一个作为HTTP “POST”操作的所有数据的字符串。</li><li>CURLOPT_REFERER: 在HTTP请求中包含一个”referer”头的字符串。</li><li>CURLOPT_USERAGENT : 在HTTP请求中包含一个”user-agent”头的字符串。</li><li>CURLOPT_FTPPORT: 传递一个包含被ftp “POST”指令使用的IP地址。这个POST指令告诉远程服务器去连接我们指定的IP地址。这个字符串可以是一个IP地址，一个主机名，一个网络界面名(在UNIX下)，或是‘-‘(使用系统默认IP地址)。</li><li>CURLOPT_COOKIE : 传递一个包含HTTP cookie的头连接。</li><li>CURLOPT_SSLCERT : 传递一个包含PEM格式证书的字符串。</li><li>CURLOPT_COOKIEFILE : 传递一个包含cookie数据的文件的名字的字符串。这个cookie文件可以是Netscape格式，或是堆存在文件中的HTTP风格的头。</li><li>CURLOPT_CUSTOMREQUEST : 当进行HTTP请求时，传递一个字符被GET或HEAD使用。为进行DELETE或其它操作是有益的，更Pass a string to be used instead of GET or HEAD when doing an HTTP request. This is useful for doing or another, more obscure, HTTP request. 注意: 在确认你的服务器支持命令先不要去这样做。下列的选项要求一个文件描述(通过使用fopen()函数获得)。</li><li>CURLOPT_FILE: 这个文件将是你放置传送的输出文件，默认是STDOUT.</li><li>CURLOPT_INFILE : 这个文件是你传送过来的输入文件。</li><li>CURLOPT_WRITEHEADER : 这个文件写有你输出的头部分。</li><li>CURLOPT_STDERR : 这个文件写有错误而不是stderr。用来获取需要登录的页面的例子,当前做法是每次或许都登录一次,有需要的人再做改进了.<h4 id="curl可以做到一些更有趣的事情，模拟登陆之类的，hhh-ˉ﹃ˉ-。ps：别忘了curl-close-hhhh"><a href="#curl可以做到一些更有趣的事情，模拟登陆之类的，hhh-ˉ﹃ˉ-。ps：别忘了curl-close-hhhh" class="headerlink" title="curl可以做到一些更有趣的事情，模拟登陆之类的，hhh(ˉ﹃ˉ)。ps：别忘了curl_close();hhhh"></a>curl可以做到一些更有趣的事情，模拟登陆之类的，hhh(ˉ﹃ˉ)。ps：别忘了curl_close();hhhh</h4></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景：&lt;/h2&gt;&lt;p&gt;学习了CURL的访问模式，卧槽真的比file_get_content()高到不知道哪里去了，几乎就是一个小型在php内部的浏览器。首
      
    
    </summary>
    
      <category term="技术" scheme="https://zx19951110.github.io/ZX.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="后端" scheme="https://zx19951110.github.io/ZX.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
</feed>
